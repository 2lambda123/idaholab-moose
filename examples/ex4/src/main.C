//Local Includes
#include "Convection.h"
#include "CoupledDirichletBC.h"
#include "CoupledNeumannBC.h"

//Moose Includes
#include "Moose.h"
#include "KernelFactory.h"
#include "BCFactory.h"
#include "MaterialFactory.h"
#include "AuxFactory.h"
#include "ComputeResidual.h"
#include "ComputeJacobian.h"

// C++ include files that we need
#include <iostream>
#include <fstream>

// libMesh includes
#include "libmesh.h"
#include "perf_log.h"
#include "mesh.h"
#include "boundary_info.h"
#include "exodusII_io.h"
#include "equation_systems.h"
#include "nonlinear_solver.h"
#include "nonlinear_implicit_system.h"
#include "linear_implicit_system.h"
#include "transient_system.h"
#include "mesh_refinement.h"
#include "getpot.h"

// Petsc includes
#include <petsc.h>

// Initialize default Performance Logging
PerfLog Moose::perf_log("Example4");

// Begin the main program.
int main (int argc, char** argv)
{
  {
    // Initialize Moose
    MooseInit init(argc, argv);

    // Create a GetPot object to parse the command line
    GetPot command_line (argc, argv);

    // A boolean telling us whether or not to use the NeumannBC
    // we are going to default it to false.
    bool use_neumann = false;
    
    // Grab a boolean from the command-line
    if(command_line.search("--use-neumann"))
      use_neumann = command_line.next(use_neumann);

    // A string and int to hold an optional mesh filename
    // and dimension
    std::string mesh_file = "square.e";
    int mesh_dim = 2;
    if(command_line.search("--mesh-file")) 
    {
      mesh_file = command_line.next(mesh_file);
      mesh_dim = command_line.next(mesh_dim);
    }
      
    // Tell PetsC to use some default preconditioning
    // by default this will build a block diagonal jacobian
    // and employ ILU0 preconditioning
    PetscOptionsSetValue("-snes_mf_operator",PETSC_NULL);

    // This registers a bunch of common objects that exist in Moose with the factories.
    // that includes several Kernels, BoundaryConditions, AuxKernels and Materials
    Moose::registerObjects();

    // Register a new kernel with the factory so we can use it in the computation.
    KernelFactory::instance()->registerKernel<Convection>("Convection");

    // Register a new boundary condition with the factory so we can use it in the computation.
    BCFactory::instance()->registerBC<CoupledDirichletBC>("CoupledDirichletBC");
    BCFactory::instance()->registerBC<CoupledNeumannBC>("CoupledNeumannBC");

    // Create the mesh object
    Mesh mesh(mesh_dim);

    // MUST set the global mesh!
    Moose::mesh = &mesh;

    // Read the mesh from an Exodus file and prepare it for use
    ExodusII_IO exreader(mesh);
    exreader.read(mesh_file);

    /**
     * The "false" specifies _not_ to renumber nodes and elements
     * this could be a slight hit to performance, but it means that your
     * output file will have the same node and element numbering as the input
     */
    mesh.prepare_for_use(false);

    /**
     * Do some uniform refinement of the mesh so we can capture the solution better.
     */
    //MeshRefinement mesh_refinement(mesh);
    //mesh_refinement.uniformly_refine(2);

    /**
     * This builds nodesets from your sidesets
     * these autogenerated nodesets are used for Dirichlet boundary conditions
     * NEVER manually create nodesets... always let the code autogenerate them
     * note that if the mesh changes (such as after adaptivity) you have to
     */
    mesh.boundary_info->build_node_list_from_side_list();

    // Print some useful information about the mesh
    mesh.print_info();

    // The equation_systems holds all the Systems we want to solve
    EquationSystems equation_systems (mesh);

    // MUST set the global equation_systems!
    Moose::equation_system = &equation_systems;

    // This is the actual Nonlinear System we are going to solve
    TransientNonlinearImplicitSystem& system =
      equation_systems.add_system<TransientNonlinearImplicitSystem> ("NonlinearSystem");

    /**
     * Add a variable named "u" to solve for.
     * We are going to approximate it using First order Lagrange FEs
     */
    system.add_variable("u", FIRST, LAGRANGE);

    /**
     * Add a variable named "v" to solve for.
     * We are going to approximate it using First order Lagrange FEs
     *
     * We are going to couple this variable into the convection kernel for variable "u"
     */
    system.add_variable("v", FIRST, LAGRANGE);

    // Set the residual and jacobian functions to the default ones provided by MOOSE
    system.nonlinear_solver->residual = Moose::compute_residual;
    system.nonlinear_solver->jacobian = Moose::compute_jacobian;

    /**
     * This is a NECESSARY auxiliary system for computing auxiliary variables
     * Even though we're not going to have any of those we MUST create this system.
     */
    TransientExplicitSystem& aux_system =
      equation_systems.add_system<TransientExplicitSystem> ("AuxiliarySystem");

    // Initialize the Systems and print some info out
    equation_systems.init();
    equation_systems.print_info();

    /**
     * Initialize common data structures for Kernels.
     * These MUST be called in this order... and at this point.
     */
    Kernel::init(&equation_systems);
    BoundaryCondition::init();
    AuxKernel::init();

    /**
     * Next we are going to define our coupling vectors.
     *
     * coupled_to = the actual name of the coupled variable
     *
     * coupled_as = the name the Kernel _expects_...
     *   This is essentially the name you pass to the Coupled*()
     *   functions when you try to get a coupled variable in a Kernel.
     *   In this case we call coupledGrad("some_var") in Convection.h
     *   therefore the variable "v" is coupled_as "some_var.
     *
     * Note that coupled_to and coupled_as are _paired_.
     */
    std::vector<std::string> conv_coupled_to;
    std::vector<std::string> conv_coupled_as;

    conv_coupled_to.push_back("v");
    conv_coupled_as.push_back("some_var");

    // Blank params to use for Kernels that don't need params
    Parameters params;

    // Parameters for DirichletBC's
    Parameters left_bc_params;
    left_bc_params.set<Real>("value") = 0.0;

    Parameters right_bc_params;
    right_bc_params.set<Real>("value") = 1.0;
    
    Parameters coupled_bc_params;
    coupled_bc_params.set<Real>("value") = 2.0;
    
    //////////////
    // "u" Kernels
    //////////////
    
    // Add a Diffusion Kernel from MOOSE into the calculation.
    KernelFactory::instance()->add("Diffusion", "diff", params, "u");

    // Add the Convection Kernel from this application into the calculation
    // Note that we are passing in our coupling vectors
    KernelFactory::instance()->add("Convection", "conv", params, "u", conv_coupled_to, conv_coupled_as);

    // Add the two boundary conditions using the DirichletBC object from MOOSE
    BCFactory::instance()->add("DirichletBC", "left",  left_bc_params,  "u", 1);

    if(use_neumann)
    {
      // Use our new CoupledNeumannBC
      BCFactory::instance()->add("CoupledNeumannBC", "right", coupled_bc_params, "u", 2, conv_coupled_to, conv_coupled_as);
    }
    else
    {
      // Use our new CoupledDirichletBC
      BCFactory::instance()->add("CoupledDirichletBC", "right", coupled_bc_params, "u", 2, conv_coupled_to, conv_coupled_as);
    }
    
    //////////////
    // "v" Kernels
    //////////////

    // Add a Diffusion Kernel from MOOSE into the calculation.
    KernelFactory::instance()->add("Diffusion", "diff", params, "v");

    // Add the two boundary conditions using the DirichletBC object from MOOSE
    BCFactory::instance()->add("DirichletBC", "left",  left_bc_params,  "v", 1);
    BCFactory::instance()->add("DirichletBC", "right", right_bc_params, "v", 2);

    
    // Every calculation MUST add at least one Material
    // Here we use the EmptyMaterial from MOOSE because we don't need material properties.
    MaterialFactory::instance()->add("EmptyMaterial", "empty", params, 1);

    // Solve the Nonlinear System
    system.solve();

    // Write the solution out.
    ExodusII_IO(mesh).write_equation_systems("out.e", equation_systems);
  }

  return 0;
}
