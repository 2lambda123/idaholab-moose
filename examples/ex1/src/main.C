//Moose Includes
#include "Moose.h"
#include "KernelFactory.h"
#include "BCFactory.h"
#include "MaterialFactory.h"
#include "AuxFactory.h"
#include "ComputeResidual.h"
#include "ComputeJacobian.h"
#include "ColumnMajorMatrix.h"

// C++ include files that we need
#include <iostream>
#include <fstream>

// libMesh includes
#include "libmesh.h"
#include "perf_log.h"
#include "mesh.h"
#include "boundary_info.h"
#include "exodusII_io.h"
#include "equation_systems.h"
#include "nonlinear_solver.h"
#include "nonlinear_implicit_system.h"
#include "linear_implicit_system.h"
#include "transient_system.h"
#include "vector_value.h"

// Initialize default Performance Logging
PerfLog Moose::perf_log("Example1");

// Begin the main program.
int main (int argc, char** argv)
{
  {
    VectorValue<Real> V(1, 2, 3);
    TensorValue<Real> T;
    
    
    ColumnMajorMatrix A(3, 2);
    ColumnMajorMatrix B(2, 3);
    ColumnMajorMatrix C;

    ColumnMajorMatrix D(9, 9);

    
    

    A(0, 0) = 1;
    A(1, 0) = 2;
    A(2, 0) = 3;
    A(0, 1) = 4;
    A(1, 1) = 5;
    A(2, 1) = 6;

    B(0, 0) = 1;
    B(0, 1) = 2;
    B(0, 2) = 3;
    B(1, 0) = 4;
    B(1, 1) = 5;
    B(1, 2) = 6;


    T(0, 0) = 1;
    T(1, 0) = 2;
    T(2, 0) = 3;
    T(0, 1) = 4;
    T(1, 1) = 5;
    T(2, 1) = 6;
    T(0, 2) = 7;
    T(1, 2) = 8;
    T(2, 2) = 9;

    for (unsigned int j=0; j<9; ++j)
      for (unsigned int i=0; i<9; ++i)
        D(i, j) = i*j;
    
    D.print();
    
    
    //C = A*B;

    //A.print();
    //B.print();
    //C.print();

    //C = B*V;

    //C.print();

    ColumnMajorMatrix E(T);
    E.reshape(9,1);
    
    C = D*E;

    C.print();
    
    
    
    
    // Initialize libMesh and any dependent libaries
    LibMeshInit init (argc, argv);

    // This registers a bunch of common objects that exist in Moose with the factories.
    // that includes several Kernels, BoundaryConditions, AuxKernels and Materials
    Moose::registerObjects();

    // Create the mesh object
    Mesh mesh(2);

    // MUST set the global mesh!
    Moose::mesh = &mesh;

    // Read the mesh from an Exodus file and prepare it for use
    ExodusII_IO exreader(mesh);
    exreader.read("square.e");

    /**
     * The "false" specifies _not_ to renumber nodes and elements
     * this could be a slight hit to performance, but it means that your
     * output file will have the same node and element numbering as the input
     */
    mesh.prepare_for_use(false);

    /**
     * This builds nodesets from your sidesets
     * these autogenerated nodesets are used for Dirichlet boundary conditions
     * NEVER manually create nodesets... always let the code autogenerate them
     * note that if the mesh changes (such as after adaptivity) you have to
     */
    mesh.boundary_info->build_node_list_from_side_list();

    // Print some useful information about the mesh
    mesh.print_info();

    // The equation_systems holds all the Systems we want to solve
    EquationSystems equation_systems (mesh);

    // MUST set the global equation_systems!
    Moose::equation_system = &equation_systems;

    // This is the actual Nonlinear System we are going to solve
    TransientNonlinearImplicitSystem& system =
      equation_systems.add_system<TransientNonlinearImplicitSystem> ("NonlinearSystem");

    /**
     * Add a variable named "u" to solve for.
     * We are going to approximate it using First order Lagrange FEs
     */
    system.add_variable("u", FIRST, LAGRANGE);

    // Set the residual and jacobian functions to the default ones provided by MOOSE
    system.nonlinear_solver->residual = Moose::compute_residual;
    system.nonlinear_solver->jacobian = Moose::compute_jacobian;

    /**
     * This is a NECESSARY auxiliary system for computing auxiliary variables
     * Even though we're not going to have any of those we MUST create this system.
     */
    TransientExplicitSystem& aux_system =
      equation_systems.add_system<TransientExplicitSystem> ("AuxiliarySystem");

    // Initialize the Systems and print some info out
    equation_systems.init();
    equation_systems.print_info();

    /**
     * Initialize common data structures for Kernels.
     * These MUST be called in this order... and at this point.
     */
    Kernel::init(&equation_systems);
    BoundaryCondition::init();
    AuxKernel::init();

    // Blank params to use for Kernels that don't need params
    Parameters params;

    // Parameters for DirichletBC's
    Parameters left_bc_params;
    left_bc_params.set<Real>("value") = 0.0;

    Parameters right_bc_params;
    right_bc_params.set<Real>("value") = 1.0;

    // Add a Diffusion Kernel from MOOSE into the calculation.
    KernelFactory::instance()->add("Diffusion", "diff", params, "u");

    // Add the two boundary conditions using the DirichletBC object from MOOSE
    BCFactory::instance()->add("DirichletBC", "left",  left_bc_params,  "u", 1);
    BCFactory::instance()->add("DirichletBC", "right", right_bc_params, "u", 2);

    // Every calculation MUST add at least one Material
    // Here we use the EmptyMaterial from MOOSE because we don't need material properties.
    MaterialFactory::instance()->add("EmptyMaterial", "empty", params, 1);

    // Solve the Nonlinear System
    system.solve();

    // Write the solution out.
    ExodusII_IO(mesh).write_equation_systems("out.e", equation_systems);
  }

  return 0;
}
