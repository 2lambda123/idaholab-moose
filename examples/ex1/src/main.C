Purposely breaking build to test bitten

//Moose Includes
#include "Moose.h"
#include "KernelFactory.h"
#include "BCFactory.h"
#include "MaterialFactory.h"
#include "AuxFactory.h"
#include "ComputeResidual.h"
#include "ComputeJacobian.h"

// C++ include files that we need
#include <iostream>
#include <fstream>

// libMesh includes
#include "libmesh.h"
#include "perf_log.h"
#include "mesh.h"
#include "boundary_info.h"
#include "exodusII_io.h"
#include "equation_systems.h"
#include "nonlinear_solver.h"
#include "nonlinear_implicit_system.h"
#include "linear_implicit_system.h"
#include "transient_system.h"

// Initialize default Performance Logging
PerfLog Moose::perf_log("Example1");

// Begin the main program.
int main (int argc, char** argv)
{
  {
    // Initialize Moose
    MooseInit init(argc, argv);

    // This registers a bunch of common objects that exist in Moose with the factories.
    // that includes several Kernels, BoundaryConditions, AuxKernels and Materials
    Moose::registerObjects();

    // Create the mesh object
    Mesh mesh(2);

    // MUST set the global mesh!
    Moose::mesh = &mesh;

    // Read the mesh from an Exodus file and prepare it for use
    ExodusII_IO exreader(mesh);
    exreader.read("square.e");

    /**
     * The "false" specifies _not_ to renumber nodes and elements
     * this could be a slight hit to performance, but it means that your
     * output file will have the same node and element numbering as the input
     */
    mesh.prepare_for_use(false);

    /**
     * This builds nodesets from your sidesets
     * these autogenerated nodesets are used for Dirichlet boundary conditions
     * NEVER manually create nodesets... always let the code autogenerate them
     * note that if the mesh changes (such as after adaptivity) you have to
     */
    mesh.boundary_info->build_node_list_from_side_list();

    // Print some useful information about the mesh
    mesh.print_info();

    // The equation_systems holds all the Systems we want to solve
    EquationSystems equation_systems (mesh);

    // MUST set the global equation_systems!
    Moose::equation_system = &equation_systems;

    // This is the actual Nonlinear System we are going to solve
    TransientNonlinearImplicitSystem& system =
      equation_systems.add_system<TransientNonlinearImplicitSystem> ("NonlinearSystem");

    /**
     * Add a variable named "u" to solve for.
     * We are going to approximate it using First order Lagrange FEs
     */
    system.add_variable("u", FIRST, LAGRANGE);

    // Set the residual and jacobian functions to the default ones provided by MOOSE
    system.nonlinear_solver->residual = Moose::compute_residual;
    system.nonlinear_solver->jacobian = Moose::compute_jacobian;

    /**
     * This is a NECESSARY auxiliary system for computing auxiliary variables
     * Even though we're not going to have any of those we MUST create this system.
     */
    TransientExplicitSystem& aux_system =
      equation_systems.add_system<TransientExplicitSystem> ("AuxiliarySystem");

    // Initialize the Systems and print some info out
    equation_systems.init();
    equation_systems.print_info();

    /**
     * Initialize common data structures for Kernels.
     * These MUST be called in this order... and at this point.
     */
    Kernel::init(&equation_systems);
    BoundaryCondition::init();
    AuxKernel::init();

    // Blank params to use for Kernels that don't need params
    Parameters params;

    // Parameters for DirichletBC's
    Parameters left_bc_params;
    left_bc_params.set<Real>("value") = 0.0;

    Parameters right_bc_params;
    right_bc_params.set<Real>("value") = 1.0;

    // Add a Diffusion Kernel from MOOSE into the calculation.
    KernelFactory::instance()->add("Diffusion", "diff", params, "u");

    // Add the two boundary conditions using the DirichletBC object from MOOSE
    BCFactory::instance()->add("DirichletBC", "left",  left_bc_params,  "u", 1);
    BCFactory::instance()->add("DirichletBC", "right", right_bc_params, "u", 2);

    // Every calculation MUST add at least one Material
    // Here we use the EmptyMaterial from MOOSE because we don't need material properties.
    MaterialFactory::instance()->add("EmptyMaterial", "empty", params, 1);

    // Solve the Nonlinear System
    system.solve();

    // Write the solution out.
    ExodusII_IO(mesh).write_equation_systems("out.e", equation_systems);
  }

  return 0;
}
