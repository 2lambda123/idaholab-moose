//Local Includes
#include "Convection.h"
#include "ExampleDiffusion.h"
#include "ExampleMaterial.h"
#include "ExampleImplicitEuler.h"

//Moose Includes
#include "Moose.h"
#include "KernelFactory.h"
#include "BCFactory.h"
#include "MaterialFactory.h"
#include "AuxFactory.h"
#include "ComputeResidual.h"
#include "ComputeJacobian.h"

// C++ include files that we need
#include <iostream>
#include <fstream>

// libMesh includes
#include "libmesh.h"
#include "perf_log.h"
#include "mesh.h"
#include "boundary_info.h"
#include "exodusII_io.h"
#include "equation_systems.h"
#include "nonlinear_solver.h"
#include "nonlinear_implicit_system.h"
#include "linear_implicit_system.h"
#include "transient_system.h"
#include "numeric_vector.h"
#include "mesh_refinement.h"
#include "getpot.h"

// Initialize default Performance Logging
PerfLog Moose::perf_log("Example7");

// Begin the main program.
int main (int argc, char** argv)
{
  {
    // Initialize libMesh and any dependent libaries
    LibMeshInit init (argc, argv);

    // Create a GetPot object to parse the command line
    GetPot command_line (argc, argv);
    
    // Will hold the name of the input file... default to blank
    std::string input_filename = "";
    
    // See if an input file was provided on the command-line
    if ( command_line.search("-i") )
      input_filename = command_line.next(input_filename);
    else
    {
      // Print a message and throw an error if the input file wasn't provided
      std::cout<<"Must specify an input file using -i"<<std::endl;
      libmesh_error();
    }

    // Create a parser for the input file
    GetPot input_file(input_filename);
    
    // The diffusivity we're going to pass to our Material
    // We're giving it a default value of 1.0
    Real diffusivity = input_file("MatProps/diffusivity",1.0);

    // The time_coefficient we're going to pass to our Material
    // We're giving it a default value of 1.0
    Real time_coefficient = input_file("MatProps/time_coefficient",1.0);

    // The timestep size to take... defaulting to 1.0
    Real input_dt = input_file("Transient/dt", 1.0);

    // This registers a bunch of common objects that exist in Moose with the factories.
    // that includes several Kernels, BoundaryConditions, AuxKernels and Materials
    Moose::registerObjects();

    // Register a new kernel with the factory so we can use it in the computation.
    KernelFactory::instance()->registerKernel<Convection>("Convection");
    KernelFactory::instance()->registerKernel<ExampleDiffusion>("ExampleDiffusion");
    KernelFactory::instance()->registerKernel<ExampleImplicitEuler>("ExampleImplicitEuler");

    // Register our new material class so we can use it.
    MaterialFactory::instance()->registerMaterial<ExampleMaterial>("ExampleMaterial");

    // Create the mesh object
    Mesh mesh(2);

    // MUST set the global mesh!
    Moose::mesh = &mesh;

    // Read the mesh from an Exodus file and prepare it for use
    ExodusII_IO exreader(mesh);
    exreader.read("square.e");

    /**
     * The "false" specifies _not_ to renumber nodes and elements
     * this could be a slight hit to performance, but it means that your
     * output file will have the same node and element numbering as the input
     */
    mesh.prepare_for_use(false);

    /**
     * Do some uniform refinement of the mesh so we can capture the solution better.
     */
    MeshRefinement mesh_refinement(mesh);
    mesh_refinement.uniformly_refine(4);

    /**
     * This builds nodesets from your sidesets
     * these autogenerated nodesets are used for Dirichlet boundary conditions
     * NEVER manually create nodesets... always let the code autogenerate them
     * note that if the mesh changes (such as after adaptivity) you have to
     */
    mesh.boundary_info->build_node_list_from_side_list();

    // Print some useful information about the mesh
    mesh.print_info();

    // The equation_systems holds all the Systems we want to solve
    EquationSystems equation_systems (mesh);

    // MUST set the global equation_systems!
    Moose::equation_system = &equation_systems;

    // This is the actual Nonlinear System we are going to solve
    TransientNonlinearImplicitSystem& system =
      equation_systems.add_system<TransientNonlinearImplicitSystem> ("NonlinearSystem");

    /**
     * Add a variable named "u" to solve for.
     * We are going to approximate it using First order Lagrange FEs
     */
    system.add_variable("u", FIRST, LAGRANGE);

    /**
     * Add a variable named "v" to solve for.
     * We are going to approximate it using First order Lagrange FEs
     *
     * We are going to couple this variable into the convection kernel for variable "u"
     */
    system.add_variable("v", FIRST, LAGRANGE);

    // Set the residual and jacobian functions to the default ones provided by MOOSE
    system.nonlinear_solver->residual = Moose::compute_residual;
    system.nonlinear_solver->jacobian = Moose::compute_jacobian;

    /**
     * This is a NECESSARY auxiliary system for computing auxiliary variables
     * Even though we're not going to have any of those we MUST create this system.
     */
    TransientExplicitSystem& aux_system =
      equation_systems.add_system<TransientExplicitSystem> ("AuxiliarySystem");

    // Initialize the Systems and print some info out
    equation_systems.init();
    equation_systems.print_info();

    /**
     * Set up Transient parameters.  For a Transient solve time, dt and t_step
     * MUST exist and MUST be set before Kernel::init()!!!!!!!
     */
    
    // The starting time
    Real & time = equation_systems.parameters.set<Real> ("time") = 0;

    // The step size
    Real & dt = equation_systems.parameters.set<Real> ("dt") = input_dt;

    // The starting step
    int & t_step = equation_systems.parameters.set<int> ("t_step") = 0;

    // Number of timesteps to take
    unsigned int num_steps = 20;
    
    /**
     * Initialize common data structures for Kernels.
     * These MUST be called in this order... and at this point.
     */
    Kernel::init(&equation_systems);
    BoundaryCondition::init();
    AuxKernel::init();

    /**
     * Next we are going to define our coupling vectors.
     *
     * coupled_to = the actual name of the coupled variable
     *
     * coupled_as = the name the Kernel _expects_...
     *   This is essentially the name you pass to the Coupled*()
     *   functions when you try to get a coupled variable in a Kernel.
     *   In this case we call coupledGrad("some_var") in Convection.h
     *   therefore the variable "v" is coupled_as "some_var.
     *
     * Note that coupled_to and coupled_as are _paired_.
     */
    std::vector<std::string> conv_coupled_to;
    std::vector<std::string> conv_coupled_as;

    conv_coupled_to.push_back("v");
    conv_coupled_as.push_back("some_var");

    // Blank params to use for Kernels that don't need params
    Parameters params;

    // Parameters for DirichletBC's
    Parameters left_bc_params;
    left_bc_params.set<Real>("value") = 0.0;

    Parameters right_bc_params;
    right_bc_params.set<Real>("value") = 1.0;

    //////////////
    // "u" Kernels
    //////////////
    
    // Add a Diffusion Kernel from MOOSE into the calculation.
    KernelFactory::instance()->add("ExampleDiffusion", "diff", params, "u");

    // Add the Convection Kernel from this application into the calculation
    // Note that we are passing in our coupling vectors
    KernelFactory::instance()->add("Convection", "conv", params, "u", conv_coupled_to, conv_coupled_as);

    // Add an ImplicitEuler Kernel for the time operator
    KernelFactory::instance()->add("ImplicitEuler", "u_ie", params, "u");

    // Add the two boundary conditions using the DirichletBC object from MOOSE
    BCFactory::instance()->add("DirichletBC", "left",  left_bc_params,  "u", 1);
    BCFactory::instance()->add("DirichletBC", "right", right_bc_params, "u", 2);


    //////////////
    // "v" Kernels
    //////////////

    // Add a Diffusion Kernel from MOOSE into the calculation.
    KernelFactory::instance()->add("Diffusion", "diff", params, "v");

    // Add an ImplicitEuler Kernel for the time operator
    KernelFactory::instance()->add("ExampleImplicitEuler", "u_ie", params, "v");

    // Add the two boundary conditions using the DirichletBC object from MOOSE
    BCFactory::instance()->add("DirichletBC", "left",  right_bc_params,  "v", 1);
    BCFactory::instance()->add("DirichletBC", "right", left_bc_params, "v", 2);

    
    // Get the default values for the ExampleMaterial's parameters
    Parameters mat_params = MaterialFactory::instance()->getValidParams("ExampleMaterial");

    // Override the default diffusivity
    mat_params.set<Real>("diffusivity") = diffusivity;

    // Override the default time_coefficient
    mat_params.set<Real>("time_coefficient") = time_coefficient;

    // Add the Example material into the calculation using the new diffusivity.
    MaterialFactory::instance()->add("ExampleMaterial", "example", mat_params, 1);

    
    // Create an output object that we can write to each timestep
    // Note that this ONLY works with Exodus!
    ExodusII_IO ex_out(mesh);

    // Write out the initial condition
    // The +1 is because Exodus starts counting from 1
    ex_out.write_timestep("out.e", equation_systems, t_step+1, time);

    for(t_step = 1; t_step <= num_steps; ++t_step)
    {
      // Solve for the next timestep
      time += dt;

      // Print out what timestep we're at and the current time
      std::cout<<std::endl<<"Solving Timestep "<<t_step<<" at time "<<time<<std::endl;

      // After time, dt or t_step change reinitDT MUST be called
      Kernel::reinitDT();
                  
      // Copy the old solutions backwards
      *system.older_local_solution = *system.old_local_solution;
      *system.old_local_solution   = *system.current_local_solution;
      *aux_system.older_local_solution = *aux_system.old_local_solution;
      *aux_system.old_local_solution   = *aux_system.current_local_solution;

      // Solve the Nonlinear System for this timestep
      system.solve();

      // Write the solution out.
      // The +1 is because Exodus numbering starts at 1
      ex_out.write_timestep("out.e", equation_systems, t_step+1, time);
    }
  }

  return 0;
}
