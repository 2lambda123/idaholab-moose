#!/usr/bin/env python

# Load the required modules
import os, sys, subprocess, re, urllib2, socket, argparse, time, multiprocessing, platform, uuid, pickle
from random import shuffle

## User class for defining machine characteristics
class Machine(object):

  ## Machine class constructor
  def __init__(self, user_data):

    # Set the various attributes of the machine
    self.address = user_data[0]
    self.cores = int(user_data[1])
    self.threads = int(user_data[2])
    self.use = int(user_data[3])
    self.network = user_data[4]
    self.name = user_data[5]

    # Test if the machine is available on the network (localhost must be available)
    if self.name == 'localhost':
      self.available = True

    else:
      self.available = self._isAvailable()

    # Attempt to get the host name from ip
    try:
      h = socket.gethostbyaddr(self.address)
      self.hostname = h[0]
    except:
      self.hostname = self.address
      self.available = False


  ## Return the Machine information
  def info(self):

    # Set the status
    if self.available:
      return formatter('Available', urllib2.unquote(self.name), self.use, self.hostname, self.address)
    else:
      return formatter('Offline', urllib2.unquote(self.name), self.use, '',self.address)

  ## Test if the machine is available
  def _isAvailable(self):

    # Run lsdistcc with the given hostname
    sub = subprocess.Popen([which('lsdistcc'), '-x', self.address],\
                           stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    status = sub.communicate()[0]

    # If empty or contians ',down' then the host is not available
    if status != None and status.find(',down') == -1:
      return True

    else:
      return False

## A function for formatting the output text
def formatter(status, name, threads, hostname, addr):
  return '| %-10s |' %status + ' %-50s |' % name + ' %-4s |' % threads + ' %-30s |' % hostname + ' %-15s |' % addr

## Function for testing the existence for a program
def which(program):
  def is_exe(fpath):
    return os.path.exists(fpath) and os.access(fpath, os.X_OK)
  fpath, fname = os.path.split(program)
  if fpath:
    if is_exe(program):
      return program
  else:
    for path in os.environ["PATH"].split(os.pathsep):
      exe_file = os.path.join(path, program)
      if is_exe(exe_file):
        return exe_file
  return None

## Class for managing the machines on the farm
class Farm(object):

  ## Class constructor
  def __init__(self, options, make_args):

    # Initialize class variables
    self._slaves = []          # list of Machine objects to build on (private)
    self._down = []            # list of Machine objects that are not working (private)
    self._network = ''         # network that the user is on (private)
    self._cache = None         # flag indicating if cache DISTCC_HOSTS was used (priavte)
    self._make_output = None   # output pipe from make (private)
    self._make_time = None     # duration of make command (private)
    self._lines = []           # lines read from the HPCSC server

    # Data to be read/written to ._dmake_file
    self._dmake_data = {}

    # Set the temporary file names
    self._dmake_file = os.path.join(os.getenv('HOME'), '.dmakerc')

    # Set the OS type
    self._system = platform.system().lower()

    # Extract the options from the command line
    self._options = options
    self._make_args = make_args

    # Create the master Machine (localhost)
    # Get the IP address of this machine, if on linux you need to get the IP address in special way to
    # avoid getting 127.0.0.1 for the local machine
    if platform.system().lower() == 'linux':
      s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
      s.connect(('inl.gov', 0))
      addr = s.getsockname()[0]
    else:
      addr = socket.gethostbyname(socket.gethostname())

    jobs = str(multiprocessing.cpu_count())
    self._master = Machine([addr, '0', jobs, jobs, '', 'localhost'])

    # Determine the network
    if self._master.address.find('204.') != -1:
      self._network = 'fn'
    else:
      self._network = 'inl'
      os.environ['no_proxy'] = '.inl.gov'

    # Set the network of the master Machine
    self._master.network = self._network

    # Read the hosts if not running a local build
    if not self._options.local:
      self._readHosts()

  ##  Execute the correct action
  def execute(self):

    # Clean up the .dmake files
    if self._options.clean:
      self._clean()

    # Print a summary, do not run make
    if self._options.summary:
      self.summary()

    # Start the distcc daemon, do not run make
    elif self._options.daemon or self._options.dedicated:
      self.startDaemon()

    # Kill the daemons, do not run make
    elif self._options.kill:
      self.killDaemon()

    # Run local build if desired, short-circut the rest of the script for speed
    elif self._options.local:
      self.local()

    # Run a distributed compile
    else:
      self.distribute()

  ## Run the build locally only
  # @return Time required for running make
  def local(self):

    # Set the DISTCC_HOSTS environment
    distcc_hosts = 'localhost/' + str(self._master.threads)

    # Get the number of jobs
    if self._options.jobs:
      jobs = self._options.jobs
    else:
      jobs = self._master.threads

    # Print the information
    self._display(distcc_hosts, jobs)

    # Run 'make'
    self._make(distcc_hosts, jobs)

  ## Run the build distributed
  # @return Time required for running make
  def distribute(self):
    # Check that the distccd daemons are running
    self._checkDaemon()

    # Check if we are running in dedicated mode, if so, stop because we are now _using_ dmake as a client
    self.manageCron()

    # Prepare the client
    distcc_hosts, jobs = self._getHosts()

    # Print the information
    self._display(distcc_hosts, jobs)

    # Run 'make'
    self._make(distcc_hosts, jobs)

  ## Run the deamon command
  def startDaemon(self):
    self.manageCron()
    self.killDaemon()
    time.sleep(1)
    self._launchDaemon()

  ## Kill the daemons
  def killDaemon(self):
    subprocess.Popen([which('killall'), 'distccd'])

  ## Print a detailed summary
  # @return A time of 0.0 (used in main function to display dmake exeuction time)
  def summary(self):

    # The summary is not available for local compiles
    if self._options.local:
      print "Summary not available when running locally"
      sys.exit()

    # Display the results
    distcc_hosts, jobs = self._initClient()
    self._options.verbose = True
    self._display(distcc_hosts, jobs)

  # A function to facilitate cronjobs. Useful for dedicated use.
  def manageCron(self):
    cron_proc = subprocess.Popen([which('crontab'), '-l'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    current_cron = cron_proc.communicate()[0]
    # Modify crontab to run dmake in dedicated mode, refreshing the list every 15 minutes
    if self._options.dedicated:
      if current_cron.find('dmake') == -1:
        current_cron += '*/15 * * * * if [ -f ~/.bash_profile ]; then source ~/.bash_profile >/dev/null 2>&1; elif [ -f ~/.bashrc ]; then source ~/.bashrc >/dev/null 2>&1; fi && dmake --dedicated --refresh --description "' + self._dmake_data['DESCRIPTION'] + ' (Dedicated Mode)"' + ' >/dev/null 2>&1\n'
        self._updateCron(current_cron)
    else:
      # Remove dmake from the users cron, if detected
      if current_cron.find('dmake --dedicated') != -1:
        cron_line = re.findall(r'.*dmake --dedicated.*\n', current_cron)[0]
        current_cron = current_cron.replace(cron_line, '')
        self._updateCron(current_cron)

  def _updateCron(self, cron_lines):
    cron_file = open(self._dmake_file + '_cron', 'w')
    cron_file.write(cron_lines)
    subprocess.Popen([which('crontab'), self._dmake_file + '_cron'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    cron_file.close()

  ## Clean the temp dmake files
  def _clean(self):
    os.remove(os.path.join(os.getenv('HOME'), '.dmakerc'));

  ## Function for reading hosts files
  def _readHosts(self):
    # Populate ._dmake_data if available
    if os.path.exists(self._dmake_file):
      try:
        fid = open(self._dmake_file, 'r')
        self._dmake_data = pickle.load(fid)
        fid.close()

      # If IndexError, EOFError or ValueError delete the file and begin anew
      except (EOFError, IndexError, ValueError):
        self._clean()

    # Set description via arguments or prompt user for description if none set
    if self._options.description[0] != socket.gethostname():
      self._dmake_data['DESCRIPTION'] = self._options.description[0]
    elif 'DESCRIPTION' not in self._dmake_data:
      self._dmake_data['DESCRIPTION'] = ''
      print 'Supply a description of your machine:'
      while self._dmake_data['DESCRIPTION'] == '':
        self._dmake_data['DESCRIPTION'] = sys.stdin.readline().split('\n')[0]

    # Extract the list of users from the HPCSC website
    try:
      if self._options.dedicated:
        use = str((int(self._master.threads) / 2))
      else:
        use = str((int(self._master.threads) / 4))

      # The file containing the list of available machines
      filename = 'https://hpcsc.inl.gov/distcc_gen?uuid=' + str(uuid.uuid3(uuid.NAMESPACE_DNS, self._master.address)) + \
                                                 '&arch=' + self._system + \
                                                 '&ip=' + self._master.address + \
                                                 '&cpus=' + str(self._master.threads) + \
                                                 '&threads=' + str(self._master.threads) + \
                                                 '&use=' + use + \
                                                 '&network=' + self._network + \
                                                 '&description=' + urllib2.quote(self._dmake_data['DESCRIPTION'])


      # Read the file
      fid = urllib2.urlopen(filename)
      self._lines = fid.read().split('\n')
      fid.close()

    # If the file fails to read run a local build
    except:# urllib2.HTTPError or urllib2.URLError:
      print 'Warning: Failed to connect to hpcsc, running locally'
      self._options.local = True
      self._lines = None

    # Extract the local copy of the hosts file, if the file doesn't exist
    # create it from the file read from server
    if not os.path.exists(self._dmake_file):
      self._dmake_data['HOST_LINES'] = self._lines
      fid = open(self._dmake_file, 'w')
      pickle.dump(self._dmake_data, fid)
      fid.close()

  ## Run the make command (private)
  # @param distcc_hosts String contaning the DISTCC_HOSTS environmental variable
  # @param jobs The -j amount to use for 'make'
  # Runs 'make', this is executed via the local() and distribute() commands
  def _make(self, distcc_hosts, jobs):

    # Set the DISTCC_HOSTS environmental variable
    os.environ['DISTCC_HOSTS'] = distcc_hosts

    # Set the verboseness of distcc
    if self._options.quiet:
      os.environ['DISTCC_VERBOSE'] = '0'

    # Build the make command
    if (self._options.dbg):
      os.environ['METHOD'] = 'dbg'
    elif (self._options.oprof):
      os.environ['METHOD'] = 'oprof'
    elif (self._options.opt):
      os.environ['METHOD'] = 'opt'
    make = ['make', '-j', str(jobs)]
    make.extend(self._make_args)

    # Run make
    strt = time.clock()
    sub = subprocess.Popen(make)

    # Wait for process to terminate
    while sub.poll() == None:
      pass

    # Print the make durration
    print 'Make Execution Time: ' + str(time.clock() - strt) + ' sec.'

  ## Print a summary of the distcc compile farm (private)
  def _display(self, distcc_hosts, jobs):

    # Setup the output list variable
    output = []

    # Print verbose information, if desired
    if self._options.verbose:

      # Print the headings
      output.append('\nMACHINE INFORMATION:')
      output.append(formatter('Status', 'Description', 'Jobs', 'Hostname', 'IP Address'))
      s = '+' + '-'*(len(output[1])-2) + '+'
      output.insert(1,s)   # top line
      output.append(s)

      # Print the master machine information
      output.append(self._master.info())
      if self._cache:
        output.append(s)

      # Print the slave machine information, if the information exists
      use = 0
      total = 0
      if len(self._slaves) > 0:
        for user in self._slaves:
          output.append(user.info())
          use += user.use
          total += user.cores
        output.append(s)

      # Print the down machine information, if the informatin exists
      if len(self._down) > 0:
        for user in self._down:
          output.append(user.info())

      # Print header for building information
      output.append(s)
      output.append('\nBUILD INFROMATION:')

    # The basic information
    if self._options.verbose:

      # Format string for information display
      frmt = '%25s: '

      # Print processors
      output.append(frmt % 'Processors Used' + str(jobs))

      # Total available
      output.append(frmt % 'Available Processors' + str(use+self._master.use))
      output.append(frmt % 'Total Processors' + str(total+self._master.cores))

      # Add make command
      make = frmt % 'Make Command' + 'make -j ' + str(jobs)
      for a in self._make_args:
        make += ' ' + a
      output.append(make)

      # Display DISTCC_HOSTS
      output.append(frmt % 'DISTCC_HOSTS' + distcc_hosts + '\n')

    else:
      output.append('Number of processors: ' + str(jobs))

    # Print the output
    for line in output:
      print line

  ## Return the distcc hosts and jobs
  def _getHosts(self):

    # If DISTCC_HOSTS has not been populated with data
    if self._options.refresh or ('DISTCC_HOSTS' not in self._dmake_data):
      return self._initClient()

    # Restart the clients if the ._dmake_file file is older than 20 min.
    elif (time.time() - os.path.getmtime(self._dmake_file)) > 1200:
      return self._initClient()

    # Use cache
    else:
      print 'Utilizing cached DISTCC_HOSTS, use --refresh flag to update'
      self._cache = True
      distcc_hosts = self._dmake_data['DISTCC_HOSTS']
      jobs = self._dmake_data['JOBS']
      return distcc_hosts, jobs

  ## Setup the distcc client (private)
  # @return String with the DISTCC_HOSTS environment
  # @return Integer with the number of jobs to run
  def _initClient(self):

    # Write a message if building DISTCC_HOSTS
    print 'Building DISTCC_HOSTS environment variable'

    # Set the cache flag to false
    self._cache = False

    # Initilize the slave machines
    self._initSlaves()

    # Create the distcc_hosts and jobs output
    jobs = 0
    distcc_hosts = ''
    for machine in self._slaves:
      if self._options.max:
        distcc_hosts += " " + machine.hostname + '/' + str(machine.threads)
        jobs += int(machine.threads)
      else:
        distcc_hosts += " " + machine.hostname + '/' + str(machine.use)
        jobs += machine.use

    # Get the default or user-defined values for localhost/localslots_cpp/localslots
    if self._options.localhost:
      localhost = self._options.localhost
    else:
      localhost = min(2, self._master.threads)

    if self._options.localslots:
      localslots = self._options.localslots
    else:
      localslots = self._master.threads/4

    if self._options.localslots_cpp:
      localslots_cpp = self._options.localslots_cpp
    else:
      localslots_cpp = self._master.threads - localhost

    # Create the DISTCC_HOSTS variable
    if jobs == 0:
      localhost = self._master.threads
      distcc_hosts = 'localhost/' + str(int(localhost))

    else:
      distcc_hosts = '--localslots=' + str(int(localslots)) + ' --localslots_cpp=' + \
                   str(int(localslots_cpp)) + ' localhost/' + str(int(localhost)) + \
                   distcc_hosts

    # Add the local machine to the jobs total
    jobs += int(localhost)

    # Override jobs if the option is given
    if self._options.jobs:
      jobs = int(self._options.jobs)
    elif not self._options.max and jobs > 70:
      jobs = 70

    # Populate ._dmake_data to be written
    self._dmake_data['DISTCC_HOSTS'] = distcc_hosts
    self._dmake_data['JOBS'] = jobs

    # Overwrite ._dmake_file file (do not save if using --max)
    if not self._options.max:
      fid = open(self._dmake_file, 'w')
      pickle.dump(self._dmake_data, fid)
      fid.close()

    # Return the hosts and jobs
    return distcc_hosts, jobs

  ## use 'ps' to see if distccd is actually running
  def _isRunning(self):
    ps_process = subprocess.Popen(['ps', '-e'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    ps_output = ps_process.communicate()[0]
    if ps_output.find('distccd') != -1:
      return True
    else:
      return False

  ## Check if the distcc daemons are running (private)
  # If the daemon command has not run in the last 4 hours
  # start/re-start the daemons using 'distccd'
  def _checkDaemon(self):

    # Print a message that the check is underway
    print 'Checking if distcc daemons need to be restarted'

    # Filter out empty strings from the lists
    self._lines = filter(None,self._lines)
    self._dmake_data['HOST_LINES'] = filter(None,self._dmake_data['HOST_LINES'])

    # Flag for writting timestamp file
    write_flag = False

    # If the file does not exist start the daemon and create. dmake file
    if not os.path.exists(self._dmake_file) or not self._isRunning():
      write_flag = True
      self._launchDaemon()

    # If the local host file lines do not match the lines from the server,
    # launch the daemon and re-write the file

    elif len(set(self._lines) - set(self._dmake_data['HOST_LINES'])) > 0:
      self._dmake_data['HOST_LINES'] = self._lines
      write_flag = True
      self._launchDaemon()

    # Write the ._dmake_data file
    if write_flag:
      print 'Updating local distcc hosts file'
      fid = open(self._dmake_file, 'w')
      pickle.dump(self._dmake_data, fid)
      fid.close()

  ## Launches the Daemon (private)
  # Runs the distccd command, to start the daemons with dmake use the
  # the --daemon option
  # \see startDaemon
  def _launchDaemon(self):

    # Return if --no-daemon was used
    if self._options.no_daemon:
      return

    # Initilize the slave macines
    self._initSlaves()

    # List of allowable commands
    allow_commands = ['gcc', 'g++', 'gfortran', 'clang', 'clang++', 'mpicc', 'mpicxx', 'cc']

    # Create the distcc .cmd_list file
    cmd_list = open(os.getenv('HOME') + '/.cmd_list', 'w')
    for command in allow_commands:
      cmd = which(command)
      if cmd != None:
        cmd_list.write(cmd + '\n')
    cmd_list.close()

    # Set the environment variable for the allowed commands
    os.environ['DISTCC_CMDLIST'] = os.getenv('HOME') + '/.cmd_list'

    # Build the distccd command
    distccd_cmd = [which('distccd'), '--daemon']
    for user in self._slaves:
      distccd_cmd.extend(['--allow', user.address])
    for user in self._down:
      distccd_cmd.extend(['--allow', user.address])

    # Set the DISTCC backoff period to something large, so if server fails it will not try again
    os.environ['DISTCC_BACKOFF_PERIOD'] = '6000'

    # Set the timeout length, if a file takes more than this amount of time to compile consider it a failure
    os.environ['DISTCC_IO_TIMEOUT'] = str(self._options.timeout)

    # Run the daemon
    print 'Launching distcc daemons'
    subprocess.Popen(distccd_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

  ## Method for reading the User (private)
  def _initSlaves(self):

    # Check if initialized
    if len(self._slaves) > 0:
      return

    # Loop through each line (user)
    for line in self._lines:

      # Skip comment lines (#)
      if len(line) == 0 or line[0] == '#':
        continue

      # Parse the input for the current line
      parts = line.split(',')

      # Skip comment lines and off-network machines
      if parts[0][0] != '#' and parts[4] == self._network:

        # Build a Machine object and populate the master/slave attributes
        machine = Machine(parts)

        # Skip this machine
        if machine.hostname == self._master.hostname or machine.address == self._master.address:
          self._master.name = machine.name
          continue

        # Store the machine as offline if it is unavilable or that use column is zero
        elif machine.use == 0 or not machine.available:
          self._down.append(machine)

        # Workers
        else:
          self._slaves.append(machine)

    # Randomize the slave list
    shuffle(self._slaves)

## Function for parsing command line arguments
def parseArguments(args=None):
  parser = argparse.ArgumentParser(description='A front-end tool for distcc')

  # Flag options
  grp0 = parser.add_argument_group('Flags for adjusting behavior of \'make\'\n' + \
                                   'These flags may be used in conjuction with each\n' + \
                                   'other (e.g., \'dmake -mvn\')')
  grp0.add_argument('--max', '-m',  action='store_true', help='Use maximum jobs across the board')
  grp0.add_argument('--quiet', '-q', action='store_true', help='Do not print compile errors/warnings')
  grp0.add_argument('--local', '-l', action='store_true', help='Run make locally with all possible threads')
  grp0.add_argument('--verbose', '-v', action='store_true', help='Show a detailed summary')
  grp0.add_argument('--no-daemon', '-n', action='store_true', help='Do not launch any daemon processes')
  grp0.add_argument('--refresh', '-r', action='store_true', help='Force a refresh of the stored DISTCC_HOSTS cache')

  # Build options
  grp1 = parser.add_argument_group('Compiler Options (listed in order of priority)\n' + \
                                   'These flags may be used in union with each other and the flags\n' + \
                                   'list in the above section (e.g., dmake -dmv)')
  grp1.add_argument('--dbg', '-d', action='store_true', help='Build in debug mode')
  grp1.add_argument('--oprof', '-p', action='store_true', help='Build in oprof mode')
  grp1.add_argument('--opt', '-o', action='store_true', help='Build in opt mode')

  # Options that do not run make
  grp2 = parser.add_argument_group('Daemon and Testings Commands (do not run \'make\')')
  grp2.add_argument('--daemon', action='store_true', help='Launch distcc as a daemon')
  grp2.add_argument('--kill', action='store_true', help='Kill distcc as a daemon')
  grp2.add_argument('--summary', '-s', action='store_true', help='Show distribution summary')

  # Advanced options
  grp3 = parser.add_argument_group('Advanced Options')
  grp3.add_argument('--jobs', '-j', type=int, help='Override the automatic job count settings')
  grp3.add_argument('--localhost', type=int, help='Override the automatic setting for the number of localhost processors to utilize')
  grp3.add_argument('--localslots', type=int, help='Override the automatic setting for the number of local compile slots')
  grp3.add_argument('--localslots_cpp', type=int, help='Override the automatic setting for the number of local preprocessor slots')
  grp3.add_argument('--timeout', type=int, default=30, help='Override the default for DISTCC_IO_TIMEOUT (default: %(default)d sec.)')
  grp3.add_argument('--allow', nargs='+', metavar=['hostname'], help='Temporarly add hostname/IP to your allow list')
  grp3.add_argument('--benchmark','-b', action='store_true', help='Run \'make cleanall\' and \'dmake\' in moose_test directory')
  grp3.add_argument('--dedicated', action='store_true', help='Identify this machine as a dedicated build box')
  grp3.add_argument('--description', nargs=1, type=str, default=[socket.gethostname()], help='Add a description to your machine (default: %(default)s)')
  grp3.add_argument('--clean', '-c', action='store_true', help='Clean up .dmake and .dmake_hosts files')

  # Allow flags to be run together
  parser.parse_args('-mqvnlrbdpoc'.split())

  # Parse the input and return the options
  (options, other_args) = parser.parse_known_args()

  # Set the refresh options if any of the following options are used
  refresh = ['max', 'localhost', 'localslots', 'localslots_cpp', 'jobs']
  for r in refresh:
    if getattr(options, r) and getattr(options, r) != parser.get_default(r):
      options.refresh = True
      break

  return (options, other_args)

# Main function
if __name__ == "__main__":

  # Extract the options from the command line
  (options, make_args) = parseArguments()

  # Run a benchmark in moose_test
  # \todo make this test your environment for moose_test directory and return an error
  if options.benchmark:
    pth = os.path.join(os.environ['HOME'], 'projects', 'trunk', 'moose_test')
    if not os.path.exists(pth):
      print 'Error: The path the moose_test was not found, benchmark option failed'
      sys.exit()

    cwd = os.getcwd()
    os.chdir(os.path.join(os.environ['HOME'], 'projects', 'trunk', 'moose_test'))
    sub = subprocess.Popen(['make', 'cleanall'])
    sub.wait()

  # Create the compile farm object and execute the build
  farm = Farm(options, make_args)
  farm.execute()

  # Return to the orginal directory if running benchmark
  if options.benchmark:
    os.chdir(cwd)
