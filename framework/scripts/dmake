#!/usr/bin/env python

# Load the required modules
import os, sys, subprocess, re, urllib2, socket, argparse, time, multiprocessing, platform, uuid
from random import shuffle

## User class for defining machine characteristics
class Machine(object):

  ## Machine class constructor
  def __init__(self, user_data):

    # Set the various attributes of the machine
    self.hostname = user_data[0]
    self.cores = int(user_data[1])
    self.threads = int(user_data[2])
    self.use = int(user_data[3])
    self.network = user_data[4]
    self.name = user_data[5]

    # Test if the machine is available on the network (localhost must be available)
    if self.name == 'localhost':
      self.available = True

    else:
      self.available = self._isAvailable()

    # Attempt to get the host ip address
    try:
      # Get the IP address, if on linux you need to get the IP address in special way to
      # avoid getting 127.0.0.1 for the local machine
      if self.name == 'localhost' and  platform.system().lower() == 'linux':
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(('inl.gov', 0))
        self.address = s.getsockname()[0]
      else:
        self.address = socket.gethostbyname(self.hostname)
    except socket.gaierror:
      self.available = False

  ## Return the Machine information
  def info(self):

    # Set the status
    if self.available:
      return formatter('Available', self.name, self.use, self.hostname, self.address)
    else:
      return formatter('Offline', self.name, self.use, self.hostname,'')

  ## Test if the machine is available
  def _isAvailable(self):

    # Run lsdistcc with the given hostname
    sub = subprocess.Popen([which('lsdistcc'), '-x', self.hostname],\
                           stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    status = sub.communicate()[0]

    # If empty or contians ',down' then the host is not available
    if status != None and status.find(',down') == -1:
      return True

    else:
      return False

## A function for formatting the output text
def formatter(status, name, threads, hostname, addr):
  return '| %-10s |' %status + ' %-40s |' % name + ' %-4s |' % threads + ' %-20s |' % hostname + ' %-15s |' % addr

## Function for testing the existence for a program
def which(program):
  def is_exe(fpath):
    return os.path.exists(fpath) and os.access(fpath, os.X_OK)
  fpath, fname = os.path.split(program)
  if fpath:
    if is_exe(program):
      return program
  else:
    for path in os.environ["PATH"].split(os.pathsep):
      exe_file = os.path.join(path, program)
      if is_exe(exe_file):
        return exe_file
  return None

## Class for managing the machines on the farm
class Farm(object):

  ## Class constructor
  def __init__(self, options, make_args):

    # Initialize class variables
    self._slaves = []          # list of Machine objects to build on (private)
    self._down = []            # list of Machine objects that are not working (private)
    self._network = ''         # network that the user is on (private)
    self._cache = None         # flag indicating if cache DISTCC_HOSTS was used (priavte)
    self._make_output = None   # output pipe from make (private)
    self._make_time = None     # duration of make command (private)

    # Set the temporary file names
    self._dmake_file = os.path.join(os.getenv('HOME'), '.dmake')
    self._dmake_hosts = os.path.join(os.getenv('HOME'), '.dmake_hosts')

    # Set the OS type
    self._system = platform.system().lower()

    # Extract the options from the command line
    self._options = options
    self._make_args = make_args

    # Create the master Machine (localhost)
    hostname = socket.getfqdn()
    jobs = str(multiprocessing.cpu_count())
    self._master = Machine([hostname, '0', jobs, jobs, '', 'localhost'])

    # Determine the network
    if self._master.address.find('204.') != -1:
      self._network = 'fn'
    else:
      self._network = 'inl'
      os.environ['no_proxy'] = '.inl.gov'

    # Set the network of the master Machine
    self._master.network = self._network

    # Extract the list of users from the HPCSC website
    try:
      if self._options.dedicated:
        use = str((int(self._master.threads) / 2))
      else:
        use = str((int(self._master.threads) / 4))

      filename = 'https://hpcsc.inl.gov/distcc_gen?uuid=' + str(uuid.uuid3(uuid.NAMESPACE_DNS, self._master.hostname)) + \
                                                '&arch=' + self._system + \
                                                '&ip=' + self._master.address + \
                                                '&cpus=' + str(self._master.threads) + \
                                                '&threads=' + str(self._master.threads) + \
                                                '&use=' + use + \
                                                '&network=' + self._network + \
                                                '&description=' + self._master.hostname

      fid = urllib2.urlopen(filename)
      self._lines = fid.read().split('\n')
      fid.close()
    except urllib2.HTTPError:
      self._lines = None

  ## Run the build locally only
  # @return Time required for running make
  def local(self):

    # Set the DISTCC_HOSTS environment
    distcc_hosts = 'localhost/' + str(self._master.threads)

    # Get the number of jobs
    if self._options.jobs:
      jobs = self._options.jobs
    else:
      jobs = self._master.threads

    # Print the information
    self._display(distcc_hosts, jobs)

    # Run 'make'
    self._make(distcc_hosts, jobs)

  ## Run the build distributed
  # @return Time required for running make
  def distribute(self):

    # If no file was found in the constructor, run locally
    if self._lines == None:
      print 'Warning: Failed to connect to hpcsc, running locally'
      self.local()
      return

    # Check that the distccd daemons are running
    self._checkDaemon()

    # Prepare the client
    distcc_hosts, jobs = self._getHosts()

    # Print the information
    self._display(distcc_hosts, jobs)

    # Run 'make'
    self._make(distcc_hosts, jobs)

  ## Run the deamon command
  def startDaemon(self):
    self.killDaemon()
    time.sleep(1)
    self._launchDaemon()

  ## Kill the daemons
  def killDaemon(self):
    subprocess.Popen([which('killall'), 'distccd'])

  ## Print a detailed summary
  # @return A time of 0.0 (used in main function to display dmake exeuction time)
  def summary(self):

    # If no file was found in the constructor, run locally
    if self._lines == None:
      print 'Error: Failed to connect to hpcsc, summary is unavailable'
      sys.exit()

    distcc_hosts, jobs = self._initClient()
    self._options.verbose = True
    self._display(distcc_hosts, jobs)

  ## Run the make command (private)
  # @param distcc_hosts String contaning the DISTCC_HOSTS environmental variable
  # @param jobs The -j amount to use for 'make'
  # Runs 'make', this is executed via the local() and distribute() commands
  def _make(self, distcc_hosts, jobs):

    # Set the DISTCC_HOSTS environmental variable
    os.environ['DISTCC_HOSTS'] = distcc_hosts

    # Set the verboseness of distcc
    if self._options.quiet:
      os.environ['DISTCC_VERBOSE'] = '0'

    # Run make
    strt = time.clock()
    make = ['make', '-j', str(jobs)]
    make.extend(self._make_args)
    sub = subprocess.Popen(make)

    # Wait for process to terminate
    while sub.poll() == None:
      pass

    # Print the make durration
    print 'Make Execution Time: ' + str(time.clock() - strt) + ' sec.'

  ## Print a summary of the distcc compile farm (private)
  def _display(self, distcc_hosts, jobs):

    # Setup the output list variable
    output = []

    # Print verbose information, if desired
    if self._options.verbose:

      # Print the headings
      output.append('\nMACHINE INFORMATION:')
      output.append(formatter('Status', 'Description', 'Jobs', 'Hostname', 'IP Address'))
      s = '+' + '-'*(len(output[1])-2) + '+'
      output.insert(1,s)   # top line
      output.append(s)

      # Print the master machine information
      output.append(self._master.info())
      if self._cache:
        output.append(s)

      # Print the slave machine information, if the information exists
      if len(self._slaves) > 0:
        for user in self._slaves:
          output.append(user.info())
        output.append(s)

      # Print the down machine information, if the informatin exists
      if len(self._down) > 0:
        for user in self._down:
          output.append(user.info())
        output.append(s)

      # Print header for building information
      output.append('\nBUILD INFROMATION:')

    # The basic information
    if self._options.verbose:

      # Format string for information display
      frmt = '%25s: '

      # Print processors
      output.append(frmt % 'Processors' + str(jobs))

      # Add make command
      make = frmt % 'Make Command' + 'make -j ' + str(jobs)
      for a in self._make_args:
        make += ' ' + a
      output.append(make)

      # Display DISTCC_HOSTS
      output.append(frmt % 'DISTCC_HOSTS' + distcc_hosts + '\n')

    else:
      output.append('Number of processors: ' + str(jobs))

    # Print the output
    for line in output:
      print line

  ## Return the distcc hosts and jobs
  def _getHosts(self):

    # If the .dmake_hosts file does not exist start the client
    if self._options.refresh or (not os.path.exists(self._dmake_hosts)):
      return self._initClient()

    # Restart the clients if the .dmake_hosts file is older than 20 min.
    elif (time.time() - os.path.getmtime(self._dmake_hosts)) > 1200:
      return self._initClient()

    # Use cache
    else:
      print 'Utilizing cached DISTCC_HOSTS, use --refresh flag to update'
      fid = open(self._dmake_hosts, 'r')
      distcc_hosts = fid.readline()
      jobs = int(fid.readline())
      fid.close()
      self._cache = True
      return distcc_hosts, jobs

  ## Setup the distcc client (private)
  # @return String with the DISTCC_HOSTS environment
  # @return Integer with the number of jobs to run
  def _initClient(self):

    # Write a message if building DISTCC_HOSTS
    print 'Building DISTCC_HOSTS environment variable'

    # Set the cache flag to false
    self._cache = False

    # Initilize the slave machines
    self._initSlaves()

    # Create the distcc_hosts and jobs output
    jobs = 0
    distcc_hosts = ''
    for machine in self._slaves:
      if self._options.max:
        distcc_hosts += " " + machine.hostname +'/' + str(machine.threads)
        jobs += int(machine.threads)
      else:
        distcc_hosts += " " + machine.hostname +'/' + str(machine.use)
        jobs += machine.use

    # Get the default or user-defined values for localhost/localslots_cpp/localslots
    if self._options.localhost:
      localhost = self._options.localhost
    else:
      localhost = min(2, self._master.threads)

    if self._options.localslots:
      localslots = self._options.localslots
    else:
      localslots = self._master.threads/4

    if self._options.localslots_cpp:
      localslots_cpp = self._options.localslots_cpp
    else:
      localslots_cpp = self._master.threads - localhost

    # Create the DISTCC_HOSTS variable
    if jobs == 0:
      localhost = self._master.threads
      distcc_hosts = 'localhost/' + str(int(localhost))

    else:
      distcc_hosts = '--localslots=' + str(int(localslots)) + ' --localslots_cpp=' + \
                   str(int(localslots_cpp)) + ' localhost/' + str(int(localhost)) + \
                   distcc_hosts

    # Add the local machine to the jobs total
    jobs += int(localhost)

    # Override jobs if the option is given
    if self._options.jobs:
      jobs = int(self._options.jobs)
    elif not self._options.max and jobs > 70:
      jobs = 70

    # Write dmake_hosts file
    fid = open(self._dmake_hosts, 'w')
    fid.write(distcc_hosts + '\n')
    fid.write(str(jobs) + '\n')
    fid.close()

    # Return the hosts and jobs
    return distcc_hosts, jobs

  ## use 'ps' to see if distccd is actually running
  def _isRunning(self):
    ps_process = subprocess.Popen(['ps', '-e'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    ps_output = ps_process.communicate()[0]
    if ps_output.find('distccd') != -1:
      return True
    else:
      return False

  ## Check if the distcc daemons are running (private)
  # If the daemon command has not run in the last 4 hours
  # start/re-start the daemons using 'distccd'
  def _checkDaemon(self):

    # Flag for writting timestamp file
    w_flag = False

    # If the file does not exist start the daemon and create. dmake file
    if not os.path.exists(self._dmake_file) or not self._isRunning():
      w_flag = True
      self._launchDaemon()

    # Open the .dmake and lanuch the daemon
    else:
      fid = open(self._dmake_file)
      t = int(fid.readline())
      fid.close()
      if (int(time.time()) - t) >= 14400:
        self._launchDaemon()
        w_flag = True

    # Write the .dmake file
    if w_flag:
      fid = open(self._dmake_file, 'w')
      fid.write(time.strftime('%s'))
      fid.close()

  ## Launches the Daemon (private)
  # Runs the distccd command, to start the daemons with dmake use the
  # the --daemon option
  # \see startDaemon
  def _launchDaemon(self):

    # Return if --no-daemon was used
    if self._options.no_daemon:
      return

    # Initilize the slave macines
    self._initSlaves()

    # List of allowable commands
    allow_commands = ['gcc', 'g++', 'gfortran', 'clang', 'clang++', 'mpicc', 'mpicxx', 'cc']

    # Create the distcc .cmd_list file
    cmd_list = open(os.getenv('HOME') + '/.cmd_list', 'w')
    for command in allow_commands:
      cmd = which(command)
      if cmd != None:
        cmd_list.write(cmd + '\n')
    cmd_list.close()

    # Set the environment variable for the allowed commands
    os.environ['DISTCC_CMDLIST'] = os.getenv('HOME') + '/.cmd_list'

    # Build the distccd command
    distccd_cmd = [which('distccd'), '--daemon']
    for user in self._slaves:
      distccd_cmd.extend(['--allow', user.address])
    for user in self._down:
      distccd_cmd.extend(['--allow', user.address])

    # Set the DISTCC backoff period to something large, so if server fails it will not try again
    os.environ['DISTCC_BACKOFF_PERIOD'] = '6000'

    # Set the timeout length, if a file takes more than this amount of time to compile consider it a failure
    os.environ['DISTCC_IO_TIMEOUT'] = str(self._options.timeout)

    # Run the daemon
    print 'Launching distcc daemons'
    subprocess.Popen(distccd_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

  ## Method for reading the User (private)
  def _initSlaves(self):

    # Check if initialized
    if len(self._slaves) > 0:
      return

    # Loop through each line (user)
    for line in self._lines:

      # Skip comment lines (#)
      if len(line) == 0 or line[0] == '#':
        continue

      # Parse the input for the current line
      parts = line.split(',')

      # Skip comment lines and off-network machines
      if parts[0][0] != '#' and parts[4] == self._network:

        # Build a Machine object and populate the master/slave attributes
        machine = Machine(parts)

        # Skip this machine
        if machine.hostname == self._master.hostname or machine.address == self._master.address:
          continue

        # Store the machine as offline if it is unavilable or that use column is zero
        elif machine.use == 0 or not machine.available:
          self._down.append(machine)

        # Workers
        else:
          self._slaves.append(machine)

    # Randomize the slave list
    shuffle(self._slaves)

## Function for parsing command line arguments
def parseArguments(args=None):
  parser = argparse.ArgumentParser(description='A front-end tool for distcc')

  # Flag options
  grp0 = parser.add_argument_group('Flags for adjusting behavior of \'make\'\n' + \
                                   'These flags may be used in conjuction with each other,\nfor ' + \
                                   'example: \'dmake -mvn\'')
  grp0.add_argument('--max', '-m',  action='store_true', help='Use maximum jobs across the board')
  grp0.add_argument('--quiet', '-q', action='store_true', help='Do not print compile errors/warnings')
  grp0.add_argument('--local', '-l', action='store_true', help='Run make locally with all possible threads')
  grp0.add_argument('--verbose', '-v', action='store_true', help='Show a detailed summary')
  grp0.add_argument('--no-daemon', '-n', action='store_true', help='Do not launch any daemon processes')
  grp0.add_argument('--refresh', '-r', action='store_true', help='Force a refresh of the stored DISTCC_HOSTS cache')

  # Options that do not run make
  grp1 = parser.add_argument_group('Daemon and Testings Commands (do not run \'make\')')
  grp1.add_argument('--daemon', action='store_true', help='Launch distcc as a daemon')
  grp1.add_argument('--kill', action='store_true', help='Kill distcc as a daemon')
  grp1.add_argument('--summary', '-s', action='store_true', help='Show distribution summary')

  # Advanced options
  grp2 = parser.add_argument_group('Advanced Options')
  grp2.add_argument('--jobs', '-j', type=int, help='Override the automatic job count settings')
  grp2.add_argument('--localhost', type=int, help='Override the automatic setting for the number of localhost processors to utilize')
  grp2.add_argument('--localslots', type=int, help='Override the automatic setting for the number of local compile slots')
  grp2.add_argument('--localslots_cpp', type=int, help='Override the automatic setting for the number of local preprocessor slots')
  grp2.add_argument('--timeout', type=int, default=30, help='Override the default for DISTCC_IO_TIMEOUT (default: %(default)d sec.)')
  grp2.add_argument('--allow', nargs='+', metavar=['hostname'], help='Temporarly add hostname/IP to your allow list')
  grp2.add_argument('--jratio', type=float, default=3, help='Remote jobs ratio utilize for computing localhost (default: %(default)d)')
  grp2.add_argument('--benchmark','-b', action='store_true', help='Run \'make cleanall\' and \'dmake\' in moose_test directory')
  grp2.add_argument('--dedicated', '-d', action='store_true', help='Identify this machine as a dedicated build box')

  # Allow flags to be run together
  parser.parse_args('-mqvdnlrb'.split())

  # Parse the input and return the options
  (options, other_args) = parser.parse_known_args()

  # Set the refresh options if any of the following options are used
  refresh = ['max', 'dedicated', 'localhost', 'localslots', 'localslots_cpp', 'jratio', 'jobs']
  for r in refresh:
    if getattr(options, r) and getattr(options, r) != parser.get_default(r):
      options.refresh = True
      break

  return (options, other_args)

# Main function
if __name__ == "__main__":

  # Extract the options from the command line
  (options, make_args) = parseArguments()

  # Run a benchmark in moose_test
  # \todo make this test your environment for moose_test directory and return an error
  if options.benchmark:
    pth = os.path.join(os.environ['HOME'], 'projects', 'trunk', 'moose_test')
    if not os.path.exists(pth):
      print 'Error: The path the moose_test was not found, benchmark option failed'
      sys.exit()

    cwd = os.getcwd()
    os.chdir(os.path.join(os.environ['HOME'], 'projects', 'trunk', 'moose_test'))
    sub = subprocess.Popen(['make', 'cleanall'])
    sub.wait()

  # Create the compile farm object
  farm = Farm(options, make_args)

  # Run local build if desired, short-circut the rest of the script for speed
  if options.local:
    farm.local()

  # Print a summary, do not run make
  elif options.summary:
    farm.summary()

  # Start the distcc daemon, do not run make
  elif options.daemon:
    farm.startDaemon()

  # Kill the daemons, do not run make
  elif options.kill:
    farm.killDaemon()

  # Run a distributed compile
  else:
    farm.distribute()

  # Return to the orginal directory if running benchmark
  if options.benchmark:
    os.chdir(cwd)
