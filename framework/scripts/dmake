#!/usr/bin/env python
import os, sys, subprocess, re, urllib2, socket, argparse, time
from random import shuffle

def getList():
  # Get real user's machines
  users_connect = urllib2.urlopen('https://hpcsc.inl.gov/ssl/HERD/distcc_list_users')
  distcc_list_users = users_connect.read().split('\n')
  distcc_list_users.pop()
  users_connect.close()
  return distcc_list_users

def launchDaemon(user_list, options):
  distccd_command = [which('distccd'), '--daemon']
  # build the --allow arguments
  if options.allow:
    for host in options.allow:
      user_list.append(host + ',,,,' + options.network + ',')
  for allowed_host in [i for i in user_list]:
    if allowed_host.find('#') == -1:
      (hostname, cores, threads, use, network, desc) = getMachine(allowed_host)
      if network == options.network:
        try:
          distccd_command.extend(['--allow', socket.gethostbyname(hostname)])
          if hostname == socket.gethostname().split('.')[0]:
            distccd_command.extend(['--jobs', str(threads)])
        except socket.gaierror:
          if options.allow:
            print 'WARNING, Hostname:', hostname, 'not found on the network. DNS error? Try entering the IP instead?'
          else:
            print 'WARNING, Hostname:', hostname, 'not found on the network. DNS error?'

  # Kill any running distccd process
  killall_process = subprocess.Popen([which('killall'), 'distccd'])
  # Wait a few to allow sockets to close
  time.sleep(3)
  # Launch the daemon process
  subprocess.Popen(distccd_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

def launchClient(user_list, options, other_args):
  distcc_hosts = []
  summary_list = []
  total_jobs = 0
  print '#'*45
  if options.summary:
    print '# description, jobs, hostname'
  if options.quiet:
    os.environ['DISTCC_VERBOSE'] = '0'
  for allowed_host in [i for i in user_list]:
    if allowed_host.find('#') == -1:
      (hostname, cores, threads, use, network, desc) = getMachine(allowed_host)
      if isAvailable(options, allowed_host):
        try:
          if options.max:
            if not Me(hostname):
              distcc_hosts.append(socket.gethostbyname(hostname) + '/' + threads)
              total_jobs += int(threads)
              if options.summary:
                summary_list.append('# ' + desc + ' : ' + threads + ' : ' + hostname + ' : ' + socket.gethostbyname(hostname))
          else:
            if not Me(hostname):
              distcc_hosts.append(socket.gethostbyname(hostname) + '/' + use)
              total_jobs += int(use)
              if options.summary:
                summary_list.append('# ' + desc + ' : ' + use + ' : ' + hostname + ' : ' + socket.gethostbyname(hostname))
        except socket.error, e:
          print '# Information: ', hostname, ' is not available'
      elif isAvailable(options, allowed_host) == None:
        pass
      else:
        if options.summary:
          print '# Information: ', hostname, ' is not available'

  # Randomize the list
  shuffle(distcc_hosts)

  # Set localslots for client machine
  for allowed_host in [i for i in user_list]:
    if allowed_host.find('#') == -1:
      (hostname, cores, threads, use, network, desc) = getMachine(allowed_host)
      if Me(hostname):
        if options.local:
          distcc_hosts = ['localhost/' + str(int(threads))]
          summary_list.append('# Localhost : ' + str(int(threads)) + ' : ' + hostname + ' : ' + socket.gethostbyname(hostname))
          total_jobs = threads
        else:
          distcc_hosts.insert(0, '--localslots=' + str(int(threads) / 4) + ' --localslots_cpp=' + str(int(threads) - 2) + ' localhost/2')
          summary_list.append('# Localhost : 2 : ' + hostname + ' : ' + socket.gethostbyname(hostname))
          total_jobs += 2

  # Print summary
  if options.summary:
    summary_list.sort()
    for machine in summary_list:
      print ''.join(machine)

  # Set job count based on processors tallied, default, or --jobs argument
  if options.max is False:
    total_jobs = options.jobs

  print '# Using', total_jobs, 'processors'
  # export the environment
  os.environ['DISTCC_HOSTS']=' '.join(distcc_hosts)
  if options.summary:
    print '# DISTCC_HOSTS= ' + os.getenv('DISTCC_HOSTS'), '\n# make -j', total_jobs, ''.join(other_args)
    print '#'*45
    return
  print '#'*45
  if len(other_args) > 0:
    make_process = subprocess.Popen(['make', '-j', str(total_jobs), ''.join(other_args)])
  else:
    make_process = subprocess.Popen(['make', '-j', str(total_jobs)])
  make_process.communicate()

def checkDaemon(user_list, options):
  if options.no_daemon:
    return
  allow_commands = ['gcc', 'g++', 'gfortran', 'clang', 'clang++', 'mpicc', 'mpicxx', 'cc']
  cmd_list = open(os.getenv('HOME') + '/.cmd_list', 'w')
  for command in allow_commands:
    cmd_list.write(which(command) + '\n')
  cmd_list.close()
  os.environ['DISTCC_CMDLIST']=os.getenv('HOME') + '/.cmd_list'
  if options.daemon or options.allow:
    launchDaemon(user_list, options)
  else:
    if os.path.exists(os.getenv('HOME') + '/.dmake'):
      dmake_file = open(os.getenv('HOME') + '/.dmake', 'r')
      dmake_time = int(dmake_file.read())
      dmake_file.close()
      if (int(time.time()) - dmake_time) >= 14400:
        dmake_file = open(os.getenv('HOME') + '/.dmake', 'w')
        dmake_file.write(time.strftime('%s'))
        dmake_file.close()
        print 'reloading daemons...'
        launchDaemon(user_list, options)
      else:
        return
    else:
      dmake_file = open(os.getenv('HOME') + '/.dmake', 'w')
      dmake_file.write(time.strftime('%s'))
      dmake_file.close()
      print 'loading daemons...'
      launchDaemon(user_list, options)

def Me(hostname):
  me = socket.gethostbyname(socket.gethostname())
  them = socket.gethostbyname(hostname)
  if me == them:
    return True

def getMachine(machine):
  return machine.split(',')

def isAvailable(options, machine):
  (hostname, cores, threads, use, network, desc) = getMachine(machine)
  lsdistcc_process = subprocess.Popen([which('lsdistcc'), '-x', hostname], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  status = lsdistcc_process.communicate()[0]
  if status != None:
    if status.find(',down') == -1 and network == options.network:
      if options.dedicated and desc.find('Dedicated') == -1:
        if hostname.split('.')[0] == socket.gethostname().split('.')[0]:
          return True
        else:
          return None
      else:
        return True
  if network != options.network:
    return None
  return False

def parseArguments(args=None):
  parser = argparse.ArgumentParser(description='distcc front end tool')
  parser.add_argument('--daemon', action='store_true', help='Launch distcc as a daemon\n ')
  parser.add_argument('--no-daemon', action='store_true', help='Do not launch any daemon processes\n ')
  parser.add_argument('--max', '-m',  action='store_true', help='Use maximum jobs across the board\n ')
  parser.add_argument('--quiet', '-q', action='store_true', help='Do not print compile errors/warnings\n ')
  parser.add_argument('--summary', '-s', action='store_true', help='Show distribution summary\n ')
  parser.add_argument('--jobs', '-j', type=int, default=70, help='Arbitrarily set job count (default: %(default)d)')
  parser.add_argument('--dedicated', '-d', action='store_true', help='Only use dedicated compile boxes')
  parser.add_argument('--local', '-l', action='store_true', help='Run make locally, do not distribute')
  parser.add_argument('--allow', nargs='+', metavar=['hostname'], help='Temporarly add hostname/IP to your allow list')
  (options, other_args) = parser.parse_known_args()
  return (options, other_args)

def which(program):
  def is_exe(fpath):
    return os.path.exists(fpath) and os.access(fpath, os.X_OK)
  fpath, fname = os.path.split(program)
  if fpath:
    if is_exe(program):
      return program
  else:
    for path in os.environ["PATH"].split(os.pathsep):
      exe_file = os.path.join(path, program)
      if is_exe(exe_file):
        return exe_file
  return None

if __name__ == "__main__":
  (options, other_args) = parseArguments()

  if socket.gethostbyname(socket.gethostname()).find('204') != -1:
    options.network = 'fn'
  else:
    options.network = 'inl'
    os.environ['no_proxy'] = 'hpcsc.inl.gov'
  user_list = getList()
  if options.daemon or options.allow:
    checkDaemon(user_list, options)
  else:
    checkDaemon(user_list, options)
    launchClient(user_list, options, other_args)
