#!/usr/bin/env python
import os, sys, subprocess, re, urllib2, socket, argparse, time

def getList():
  # Get real user's machines
  users_connect = urllib2.urlopen('https://hpcsc.inl.gov/ssl/HERD/distcc_list_users')
  distcc_list_users = users_connect.read().split('\n')
  distcc_list_users.pop()
  users_connect.close()
  return distcc_list_users

def launchDaemon(user_list, options):
  distccd_command = [which('distccd'), '--daemon']
  # build the --allow arguments
  for allowed_host in [i for i in user_list]:
    if allowed_host.find('#') == -1:
      (hostname, cores, threads, use, network, desc) = getMachine(allowed_host)
      try:
        distccd_command.extend(['--allow', socket.gethostbyname(hostname)])
        if hostname == socket.gethostname().split('.')[0]:
          distccd_command.extend(['--jobs', str(threads)])
      except socket.gaierror:
        print 'WARNING, Hostname:', hostname, 'not found on the network. DNS error?'
   
  # Kill any running distccd process
  killall_process = subprocess.Popen([which('killall'), 'distccd'])
  # Wait a few to allow sockets to close
  time.sleep(3)
  # Launch the daemon process
  subprocess.Popen(distccd_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

def launchClient(user_list, options, other_args):
  distcc_hosts = []
  total_jobs = 0
  print '#'*45
  if options.summary:
    print '# description, jobs, hostname'
  if options.quiet:
    os.environ['DISTCC_VERBOSE'] = '0'
  for allowed_host in [i for i in user_list]:
    if allowed_host.find('#') == -1:
      (hostname, cores, threads, use, network, desc) = getMachine(allowed_host)
      if isAvailable(hostname):
        if hostname == socket.gethostname().split('.')[0]:
          distcc_hosts.insert(0, '--localslots=' + str(int(threads) / 4) + ' --localslots_cpp=' + str(int(threads) - 2) + ' localhost/2')
          total_jobs += 2
        else:
          if options.max:
            distcc_hosts.extend([socket.gethostbyname(hostname) + '/' + threads])
            total_jobs += int(threads)
            if options.summary:
              print '#', desc, threads, hostname
          else:
            distcc_hosts.extend([socket.gethostbyname(hostname) + '/' + use])
            total_jobs += int(use)
            if options.summary:
              print '#', desc, use, hostname
      else:
        if options.summary:
          print '#', desc, 'not available', hostname
  print '# Using', total_jobs, 'processors'
  print '#'*45
  # export the environment
  os.environ['DISTCC_HOSTS']=' '.join(distcc_hosts)
#  print 'Environment:', os.getenv('DISTCC_HOSTS'), '\nmake -j', total_jobs, ''.join(other_args)
  if len(other_args) > 0:
    make_process = subprocess.Popen(['make', '-j', str(total_jobs), ''.join(other_args)])
  else:
    make_process = subprocess.Popen(['make', '-j', str(total_jobs)])
  make_process.communicate()

def getMachine(machine):
  return machine.split(',')

def isAvailable(machine):
  lsdistcc_process = subprocess.Popen([which('lsdistcc'), '-x', machine.split(',')[0]], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  status = lsdistcc_process.communicate()[0]
  if status != None:
    if status.find(',down') == -1:
      return True
  return False

def parseArguments(args=None):
  parser = argparse.ArgumentParser(description='distcc front end tool')
  parser.add_argument('--daemon', metavar='', action='store_const', const=True, default=False, help='Launch distcc as a daemon (distccd --daemon)\n ')
  parser.add_argument('--max', metavar='', action='store_const', const=True, default=False, help='Use maximum jobs across the board\n ')
  parser.add_argument('--quiet', metavar='', action='store_const', const=True, default=False, help='Do not print compile errors/warnings\n ')
  parser.add_argument('--summary', metavar='', action='store_const', const=True, default=False, help='Show distribution summary\n ')
  return parser.parse_known_args()

def which(program):
  def is_exe(fpath):
    return os.path.exists(fpath) and os.access(fpath, os.X_OK)
  fpath, fname = os.path.split(program)
  if fpath:
    if is_exe(program):
      return program
  else:
    for path in os.environ["PATH"].split(os.pathsep):
      exe_file = os.path.join(path, program)
      if is_exe(exe_file):
        return exe_file
  return None

if __name__ == "__main__":
  (options, other_args) = parseArguments()
  if socket.gethostbyname(socket.gethostname()).find('134') != -1:
    options.type = 'inl'
  else:
    options.type = 'fn'
  user_list = getList()
  if options.daemon:
    allow_commands = ['gcc', 'g++', 'gfortran', 'clang', 'clang++', 'mpicc', 'mpicxx']
    os.environ['DISTCC_CMDLIST']=' '.join([which(i) for i in allow_commands])
    launchDaemon(user_list, options)
  else:
    launchClient(user_list, options, other_args)
