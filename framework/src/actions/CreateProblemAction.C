//* This file is part of the MOOSE framework
//* https://www.mooseframework.org
//*
//* All rights reserved, see COPYRIGHT for full restrictions
//* https://github.com/idaholab/moose/blob/master/COPYRIGHT
//*
//* Licensed under LGPL 2.1, please see LICENSE for details
//* https://www.gnu.org/licenses/lgpl-2.1.html

#include "CreateProblemAction.h"
#include "Factory.h"
#include "FEProblem.h"
#include "EigenProblem.h"
#include "NonlinearSystemBase.h"
#include "MooseApp.h"

registerMooseAction("MooseApp", CreateProblemAction, "create_problem");

registerMooseAction("MooseApp", CreateProblemAction, "set_problem_parameters");

template <>
InputParameters
validParams<CreateProblemAction>()
{
  MultiMooseEnum coord_types("XYZ RZ RSPHERICAL", "XYZ");
  MooseEnum rz_coord_axis("X=0 Y=1", "Y");

  InputParameters params = validParams<MooseObjectAction>();
  params.addParam<std::string>("type", "FEProblem", "The Problem type");
  params.addParam<std::string>("name", "MOOSE Problem", "The name the problem");
  params.addParam<std::vector<SubdomainName>>("block", "Block IDs for the coordinate systems");
  params.addParam<MultiMooseEnum>(
      "coord_type", coord_types, "Type of the coordinate system per block param");
  params.addParam<MooseEnum>(
      "rz_coord_axis", rz_coord_axis, "The rotation axis (X | Y) for axisymetric coordinates");
  params.addParam<bool>(
      "kernel_coverage_check", true, "Set to false to disable kernel->subdomain coverage check");
  params.addParam<bool>("material_coverage_check",
                        true,
                        "Set to false to disable material->subdomain coverage check");
  params.addParam<bool>("parallel_barrier_messaging",
                        true,
                        "Displays messaging from parallel "
                        "barrier notifications when executing "
                        "or transferring to/from Multiapps "
                        "(default: true)");

  params.addParam<FileNameNoExtension>("restart_file_base",
                                       "File base name used for restart (e.g. "
                                       "<path>/<filebase> or <path>/LATEST to "
                                       "grab the latest file available)");

  params.addParam<std::vector<TagName>>("extra_tag_vectors",
                                        "Extra vectors to add to the system that can be filled by "
                                        "objects which compute residuals and Jacobians (Kernels, "
                                        "BCs, etc.) by setting tags on them.");

  params.addParam<std::vector<TagName>>("extra_tag_matrices",
                                        "Extra matrices to add to the system that can be filled "
                                        "by objects which compute residuals and Jacobians "
                                        "(Kernels, BCs, etc.) by setting tags on them.");

  return params;
}

CreateProblemAction::CreateProblemAction(InputParameters parameters)
  : MooseObjectAction(parameters),
    _blocks(getParam<std::vector<SubdomainName>>("block")),
    _coord_sys(getParam<MultiMooseEnum>("coord_type")),
    _use_this_action(true)
{
}

void
CreateProblemAction::act()
{
  if (_current_task == "create_problem")
  {
    /** There's a possibilty that multipole "CreateProblem" blocks exist. This would happen if the
     */
    const auto & action_list = _awh.getActionListByName("create_problem");

    /**
     * Is there more than one CreateProblem Action? If so, we want to run the one created by the
     * custom user Action, not the autogenerated one (from DetermineSystemType Action). However,
     * we still need to check that there is sanity among the requested types.
     */
    if (action_list.size() > 1)
      _use_this_action = checkSanity(action_list);

    // build the problem only if we have mesh and we want to use this action (when there's two)
    if (_mesh.get() != NULL && _use_this_action)
    {
      _moose_object_pars.set<MooseMesh *>("mesh") = _mesh.get();
      _moose_object_pars.set<bool>("use_nonlinear") = _app.useNonlinear();

      _problem =
          _factory.create<FEProblemBase>(_type, getParam<std::string>("name"), _moose_object_pars);
      if (!_problem.get())
        mooseError("Problem has to be of a FEProblemBase type");

      // if users provide a problem type, the type has to be an EigenProblem or its derived
      // subclass when using an eigen executioner
      if (_app.useEigenvalue() && _type != "EigenProblem" &&
          !(std::dynamic_pointer_cast<EigenProblem>(_problem)))
        mooseError("Problem has to be of a EigenProblem (or derived subclass) type when using "
                   "eigen executioner");
    }
  }
  else if (_current_task == "set_problem_parameters" && _use_this_action)
  {
    // set up the problem
    _problem->setCoordSystem(_blocks, _coord_sys);
    _problem->setAxisymmetricCoordAxis(getParam<MooseEnum>("rz_coord_axis"));
    _problem->setKernelCoverageCheck(getParam<bool>("kernel_coverage_check"));
    _problem->setMaterialCoverageCheck(getParam<bool>("material_coverage_check"));
    _problem->setParallelBarrierMessaging(getParam<bool>("parallel_barrier_messaging"));

    if (isParamValid("restart_file_base"))
    {
      std::string restart_file_base = getParam<FileNameNoExtension>("restart_file_base");

      std::size_t slash_pos = restart_file_base.find_last_of("/");
      std::string path = restart_file_base.substr(0, slash_pos);
      std::string file = restart_file_base.substr(slash_pos + 1);

      /**
       * If the user specified LATEST as the file in their directory path, find the file with the
       * latest timestep and the largest serial number.
       */
      if (file == "LATEST")
      {
        std::list<std::string> dir_list(1, path);
        std::list<std::string> files = MooseUtils::getFilesInDirs(dir_list);
        restart_file_base = MooseUtils::getLatestAppCheckpointFileBase(files);

        if (restart_file_base == "")
          mooseError("Unable to find suitable restart file");
      }

      _console << "\nUsing " << restart_file_base << " for restart.\n\n";
      _problem->setRestartFile(restart_file_base);
    }

    // Create etra vectors and matrices if any
    CreateTagVectors();
  }
}

void
CreateProblemAction::CreateTagVectors()
{
  // add vectors and their tags to system
  auto & vectors = getParam<std::vector<TagName>>("extra_tag_vectors");
  auto & nl = _problem->getNonlinearSystemBase();
  for (auto & vector : vectors)
  {
    auto tag = _problem->addVectorTag(vector);
    nl.addVector(tag, false, GHOSTED);
  }

  // add matrices and their tags
  auto & matrices = getParam<std::vector<TagName>>("extra_tag_matrices");
  for (auto & matrix : matrices)
  {
    auto tag = _problem->addMatrixTag(matrix);
    nl.addMatrix(tag);
  }
}

bool
CreateProblemAction::checkSanity(const std::list<Action *> & action_list) const
{
  std::string hard_type;
  bool parser_action_hard_type = false;
  bool am_i_parser_action = _moose_object_pars.blockLocation() != "";

  unsigned int counter = 0;
  for (auto action : action_list)
  {
    auto moose_obj = dynamic_cast<MooseObjectAction *>(action);
    mooseAssert("moose_obj", "CreateProblemAction is not a MooseObjectAction");

    const auto & params = moose_obj->parameters();

    // Was this Action created by the Parser?
    if (!params.isParamSetByAddParam("type"))
    {
      if (params.blockLocation() != "")
        parser_action_hard_type = true;

      auto current_type = moose_obj->getMooseObjectType();
      if (hard_type == "")
        hard_type = current_type;
      else if (hard_type != current_type)
        mooseError("User requested problem types conflict: ", current_type, " and ", hard_type);
    }
  }

  if (counter++ > 1)
    mooseError("Too many CreateProblemActions in the system. Make sure that you don't have "
               "multiple user-defined Actions that create Problems!");

  // We'll keep the Parser Generated block unless type isn't specified.
  return parser_action_hard_type == am_i_parser_action;
}
