#!/usr/bin/env python
import sys, os, importlib, argparse, inspect, pkgutil, time
from StringIO import StringIO
from src.base import *
from src.utils import TestObject, colorText
from PySide import QtGui

import tests

##
# A class for running all available tests, this utilizes
# the base class, PeacockTestInterface, for running the tests
class PeacockTester(object):
  def __init__(self, **kwargs):

    # Parse tester options
    self._options = dict()
    self._options['verbose'] = kwargs.pop('verbose', False)
    self._options['quiet'] = kwargs.pop('quiet', False)


    self._test_objects = []

    app  = QtGui.QApplication(sys.argv)

    #prefix = tests.__name__ + "."
    for importer, modname, ispkg in pkgutil.iter_modules(tests.__path__, tests.__name__ + '.'):
      #print "Found submodule %s (is a package: %s)" % (modname, ispkg)
      module = __import__(modname, fromlist="dummy")
      #print "Imported", module

      for name, obj in inspect.getmembers(module):
        if inspect.isclass(obj):
          instance = obj(app=app)
          if isinstance(instance, TestObject):
            self._test_objects.append(instance)

          #print name,obj

    #print self._test_objects

  ##
  # Performs the testing by calling all functions
  def execute(self):

    start_time = time.time()
    num_tests = 0
    failed = 0

    # This needs to be threaded
    for objects in self._test_objects:
      for test in objects.tests:
        num_tests += 1
        name = test['name']
        attr = test['attr']

        print 'Running', name
        backup = sys.stdout
        sys.stdout = StringIO()     # capture output


        (result, msg) = attr()
#      try:
#        (result, msg) = attr()
#      except:
#        result = False
#        msg = 'RUN ERROR'

        if not result:
          failed += 1

        out = sys.stdout.getvalue() # release output
        sys.stdout.close()  # close the stream
        sys.stdout = backup # restore original stdout

        self._showTestResult(name, result, msg, out)


    # Print the summary
    print '-'*110
    print 'Executed', str(num_tests), 'in', str(time.time() - start_time), 'seconds'
    print  colorText(str(num_tests - failed) + ' passed', 'GREEN') + ', ' \
           + colorText(str(failed) + ' failed', 'RED')


  ##
  # Show the pass/fail result in typical MOOSE run_tests style
  # @param name The name of the test
  # @param result True/False result of the test
  # @param msg A message to show upon failure
  # @param stdout The stbdout string from the test execution, prints if failed
  def _showTestResult(self, name, result, msg, *args):

    # Build the status message: OK or FAIL
    if result:
      color = 'GREEN'
      msg = colorText('OK', color)
      msg_length = 2
    else:
      color = 'RED'
      msg_length = len(msg) + 7
      msg = colorText('(' + msg + ') FAIL', color)

    # Produce the complete test message string
    n = 110 - len(name) - msg_length
    print name + '.'*n + msg

    # Do not show any test output if --quiet is used
    if self._options['quiet']:
      return

    # Print the error message, if the test fails
    if not self._options['quiet'] and len(args) > 0 and (not result or (self._options['verbose'])):
      for line in args[0].splitlines():
        print colorText(name + ': ', color) + line


    #self.io.execute()
    #self.io.test()


#    self._buildTests()

  ##
  # Walks through the tests directory and registers a test
  # for each executable function that exists
#  def _buildTests(self):
#
#    # Walk through all files and directories in the 'tests' path
#    for root, dirs, files in os.walk('tests'):
#
#      # For each file, if the file is a .py file and not a module file it might contain tests
#      for f in files:
#        if f.endswith('.py') and f != '__init__.py' and not f.startswith('.'):
#
#          # Build and load the module
#          prefix, ext = os.path.splitext(os.path.join(root, f))
#          mod, ext = os.path.splitext(root)
#          mod = mod.replace('/','.')
#          i = importlib.import_module(mod)
#
#          # Look through all items in the module, if the items
#          # is executable register it as a test
#          for item in dir(i):
#            attr = getattr(i, item)
#            if hasattr(attr, '__call__') and not inspect.isclass(attr):
#              name = prefix + '.' + item
#              if self._search == None or self._search in name:
#                self.registerTest(attr, name)


# Main
if __name__ == '__main__':

  # Command-line arguments
  parser = argparse.ArgumentParser(description='run_tests: A function for executing GUI tests.')
  parser.add_argument('--verbose', '-v', action='store_true', help='Display all test output')
  parser.add_argument('--quiet', '-q', action='store_true', help='Disable display of all test output')
  parser.add_argument('--search', help='Limit testing to tests that contain the supplied search text')
  options = parser.parse_args()

  # Run the tests
  tester = PeacockTester(**vars(options))
  tester.execute()
