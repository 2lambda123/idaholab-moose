#!/usr/bin/env python
import os, importlib, argparse, inspect
from src.base import *

##
# A class for running all available tests, this utilizes
# the base class, PeacockTestInterface, for running the tests
class PeacockTester(PeacockTestInterface):
  def __init__(self, **kwargs):

    self._search = kwargs.pop('search', None)

    PeacockTestInterface.__init__(self, **kwargs)

    self._buildTests()

  ##
  # Walks through the tests directory and registers a test
  # for each executable function that exists
  def _buildTests(self):

    # Walk through all files and directories in the 'tests' path
    for root, dirs, files in os.walk('tests'):

      # For each file, if the file is a .py file and not a module file it might contain tests
      for f in files:
        if f.endswith('.py') and f != '__init__.py' and not f.startswith('.'):

          # Build and load the module
          prefix, ext = os.path.splitext(os.path.join(root, f))
          mod, ext = os.path.splitext(root)
          mod = mod.replace('/','.')
          i = importlib.import_module(mod)

          # Look through all items in the module, if the items
          # is executable register it as a test
          for item in dir(i):
            attr = getattr(i, item)
            if hasattr(attr, '__call__') and not inspect.isclass(attr):
              name = prefix + '.' + item
              if self._search == None or self._search in name:
                self.registerTest(attr, name)


# Main
if __name__ == '__main__':

  # Command-line arguments
  parser = argparse.ArgumentParser(description='run_tests: A function for executing GUI tests.')
  parser.add_argument('--verbose', '-v', action='store_true', help='Display all test output')
  parser.add_argument('--quiet', '-q', action='store_true', help='Disable display of all test output')
  parser.add_argument('--search', help='Limit testing to tests that contain the supplied search text')
  options = parser.parse_args()

  # Run the tests
  tester = PeacockTester(**vars(options))
  tester.test()
