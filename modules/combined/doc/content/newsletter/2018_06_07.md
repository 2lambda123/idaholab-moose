# MOOSE Newsletter (June 2018)

## VectorPostprocessor Parallel Consistency

Just as with `Postprocessors`, the outputs of `VectorPostprocessors` (VPPs) are able to be coupled back into other MOOSE objects.  However, there is one issue: the vectors a VPP produces are only required to be complete on "processor 0" (the root MPI process).  So, if you are needing the value of a VPP in a `Kernel` (which will most-likely be running on all of the MPI processes) something needs to be done to make the complete vectors available on all of the MPI processes.

A [new capability](https://github.com/idaholab/moose/pull/11428) was added to MOOSE this month that automatically handles the parallelism of VPP output.  To tell MOOSE that you need a complete copy of the vector on every processor you will now add an extra argument to `getVectorPostprocessorValue()` like so:

```c++
getVectorPostprocessorValue('the_vpp_parameter_name', 'the_vector_name', true)
```

The `true` is the new part.  By passing this MOOSE will completely handle the parallelism for you and you are free to use the vector values on all processors.

In addition a new function called `getScatterVectorPostprocessorValue()` was added to help in the case that a VPP produces vectors that are `num_procs` in length and your object only needs to access it's entry in that vector.

For more information on all of this check out the bottom of the [/VectorPostprocessors/index.md] page.


## MooseMesh::clone()

The `MooseMesh::clone()` interface returns a *reference* to the object it allocates, which
makes it easy to forget to explicitly delete the object when you are done with it. The
new `MooseMesh::safeClone()` method, which returns a `std::unique_ptr<MooseMesh>` should
be used instead. `MooseMesh::clone()` has been reimplemented as a `mooseError()` at the
base class level, and should no longer be called or overridden by user code. It will
eventually be removed altogether.

## PorousFlowJoiner materials

The [Porous Flow](modules/porous_flow/index.md) module now automatically adds all of the
[`PorousFlowJoiner`](PorousFlowJoiner.md) materials that are required, so there is no need
to include these pesky objects yourself! While your current input files will still continue
to run unchanged, you may want to delete these objects, and forget about them forevermore.

## Mesh Exploder

!row!
!col! class=s12 m8 l8
The visualization tool ([chigger/index.md]) that is the basis of the Peacock GUI now has the ability to
visualize a partitioned mesh by "exploding" the elements on each processor. The test script
below creates the image shown in [chigger-exploder].

!listing python/chigger/tests/nemesis/explode.py start=import

!col-end!

!col! class=s12 m4 l4
!media chigger/exploder.png
       id=chigger-exploder
       caption=Visualization of parallel partition using
               the [chigger/index.md] script.
!col-end!
!row-end!