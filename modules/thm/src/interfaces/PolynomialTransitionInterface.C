#include "PolynomialTransitionInterface.h"

#include "libmesh/dense_matrix.h"
#include "libmesh/dense_vector.h"

template <>
InputParameters
validParams<PolynomialTransitionInterface>()
{
  InputParameters params = validParams<SmoothTransitionInterface>();
  return params;
}

PolynomialTransitionInterface::PolynomialTransitionInterface(const MooseObject * moose_object)
  : SmoothTransitionInterface(moose_object),

    _A(0.0),
    _B(0.0),
    _C(0.0),
    _D(0.0),

    _initialized_transition_data(false)
{
}

void
PolynomialTransitionInterface::initializeTransitionData(const Real & f1_end_value,
                                                        const Real & f2_end_value,
                                                        const Real & df1dx_end_value,
                                                        const Real & df2dx_end_value)
{
  // compute cubic polynomial coefficients

  DenseMatrix<Real> mat(4, 4);

  mat(0, 0) = std::pow(_x1, 3);
  mat(0, 1) = std::pow(_x1, 2);
  mat(0, 2) = _x1;
  mat(0, 3) = 1.0;

  mat(1, 0) = std::pow(_x2, 3);
  mat(1, 1) = std::pow(_x2, 2);
  mat(1, 2) = _x2;
  mat(1, 3) = 1.0;

  mat(2, 0) = 3.0 * std::pow(_x1, 2);
  mat(2, 1) = 2.0 * _x1;
  mat(2, 2) = 1.0;
  mat(2, 3) = 0.0;

  mat(3, 0) = 3.0 * std::pow(_x2, 2);
  mat(3, 1) = 2.0 * _x2;
  mat(3, 2) = 1.0;
  mat(3, 3) = 0.0;

  DenseVector<Real> rhs(4);
  rhs(0) = f1_end_value;
  rhs(1) = f2_end_value;
  rhs(2) = df1dx_end_value;
  rhs(3) = df2dx_end_value;

  DenseVector<Real> coefs(4);
  mat.lu_solve(rhs, coefs);

  _A = coefs(0);
  _B = coefs(1);
  _C = coefs(2);
  _D = coefs(3);

  _initialized_transition_data = true;
}

Real
PolynomialTransitionInterface::computeTransitionValue(const Real & x,
                                                      const Real & f1,
                                                      const Real & f2) const
{
  mooseAssert(_initialized_transition_data, "initializeTransitionData() must be called.");

  if (x <= _x1)
    return f1;
  else if (x >= _x2)
    return f2;
  else
    return _A * std::pow(x, 3) + _B * std::pow(x, 2) + _C * x + _D;
}

Real
PolynomialTransitionInterface::computeTransitionValueDerivative(const Real & x,
                                                                const Real & df1dx,
                                                                const Real & df2dx) const
{
  mooseAssert(_initialized_transition_data, "initializeTransitionData() must be called.");

  if (x <= _x1)
    return df1dx;
  else if (x >= _x2)
    return df2dx;
  else
    return 3.0 * _A * std::pow(x, 2) + 2.0 * _B * x + _C;
}
