#include "Shaft.h"
#include "ShaftConnectable.h"
#include "FlowConnection.h"

registerMooseObject("THMApp", Shaft);

InputParameters
Shaft::validParams()
{
  InputParameters params = Component::validParams();
  params.addParam<Real>("scaling_factor_omega", 1.0, "Scaling factor for omega [-]");
  params.addParam<Real>("initial_speed", 0, "Initial shaft speed");
  params.addRequiredParam<std::vector<std::string>>("connected_components",
                                                    "Names of the connected components");
  params.addClassDescription("Component that connects torque of turbomachinery components");
  return params;
}

Shaft::Shaft(const InputParameters & parameters)
  : Component(parameters),
    _scaling_factor_omega(getParam<Real>("scaling_factor_omega")),
    _initial_speed(getParam<Real>("initial_speed")),
    _omega_var_name(genName(name(), "omega")),
    _connected_components(getParam<std::vector<std::string>>("connected_components"))
{
  for (auto & comp_name : _connected_components)
    addDependency(comp_name);
}

void
Shaft::init()
{
  Component::init();

  for (const std::string comp_name : _connected_components)
  {
    if (hasComponentByName<Component>(comp_name))
    {
      const Component & c = getComponentByName<Component>(comp_name);
      const ShaftConnectable & scc = dynamic_cast<const ShaftConnectable &>(c);
      scc.setShaftName(name());
    }
  }
}

void
Shaft::check() const
{
  if (_connected_components.size() == 0)
    logError("No components are connected to the shaft.");
}

void
Shaft::addVariables()
{
  std::vector<SubdomainName> connected_subdomains;
  for (const std::string comp_name : _connected_components)
  {
    const Component & c = getComponentByName<Component>(comp_name);
    if (dynamic_cast<const FlowConnection *>(&c) != nullptr)
    {
      const FlowConnection & fc = dynamic_cast<const FlowConnection &>(c);
      auto fc_csdn = fc.getConnectedSubdomainNames();
      connected_subdomains.insert(connected_subdomains.end(), fc_csdn.begin(), fc_csdn.end());
    }
  }

  if (connected_subdomains.size() > 0)
    _sim.addSimVariable(
        true, _omega_var_name, FEType(FIRST, SCALAR), connected_subdomains, _scaling_factor_omega);
  else
    _sim.addSimVariable(true, _omega_var_name, FEType(FIRST, SCALAR), _scaling_factor_omega);
  _sim.addConstantScalarIC(_omega_var_name, _initial_speed);
}

void
Shaft::addMooseObjects()
{
  std::vector<UserObjectName> uo_names;

  for (const std::string comp_name : _connected_components)
  {
    const Component & c = getComponentByName<Component>(comp_name);
    const ShaftConnectable & scc = dynamic_cast<const ShaftConnectable &>(c);
    uo_names.push_back(scc.getShaftConnectedUserObjectName());
  }

  {
    std::string class_name = "ShaftTimeDerivativeScalarKernel";
    InputParameters params = _factory.getValidParams(class_name);
    params.set<NonlinearVariableName>("variable") = _omega_var_name;
    params.set<std::vector<UserObjectName>>("uo_names") = {uo_names};
    _sim.addScalarKernel(class_name, genName(name(), "td"), params);
  }

  for (std::size_t i = 0; i < uo_names.size(); i++)
  {
    std::string class_name = "ShaftComponentTorqueScalarKernel";
    InputParameters params = _factory.getValidParams(class_name);
    params.set<NonlinearVariableName>("variable") = _omega_var_name;
    params.set<UserObjectName>("shaft_connected_component_uo") = uo_names[i];
    _sim.addScalarKernel(class_name, genName(name(), i, "shaft_speed"), params);
  }
}

VariableName
Shaft::getOmegaVariableName() const
{
  return _omega_var_name;
}
