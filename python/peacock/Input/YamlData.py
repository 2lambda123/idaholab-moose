#!/usr/bin/env python
from peacock.utils import ExeLauncher
import json
import cStringIO
import mooseutils

import yaml
try:
    from yaml import CLoader as Loader
except ImportError:
    print("********* Warning: Your PyYAML does not use libyaml. Loading will be MUCH slower! ************")
    from yaml import Loader

class YamlData(object):
    """
    Class that holds the yaml produced by an executable.
    """

    def __init__(self, app_path="", **kwds):
        """
        Constructor.
        Input:
            app_path: Path to the executable.
        """
        super(YamlData, self).__init__(**kwds)

        self.yaml_data = None
        self.app_path = None
        self.all_paths = {}
        if app_path:
            self.appChanged(app_path)

    def appChanged(self, app_path):
        """
        Called when the executable changed.
        Input:
            app_path: New executable path
        """
        try:
            raw_data = self._getRawDump(app_path)
            self._processRawData(raw_data)
            self.app_path = app_path
        except Exception as e:
            mooseutils.mooseWarning("Failed to load yaml from '%s': %s" % (app_path, e))

    def _processRawData(self, raw_data):
        """
        Process the raw data generated by the executable.
        Input:
            raw_data: Raw data
        Signals:
            yaml_changed: The YAML data has changed.
        """
        self.yaml_data = yaml.load(raw_data, Loader=Loader)
        self._createMasterDict()

    def _addToMasterDict(self, current_yaml):
        if current_yaml["parameters"]:
            params = {}
            for param in current_yaml["parameters"]:
                params[param["name"]] = param
            current_yaml["parameters_dict"] = params

        if current_yaml["subblocks"]:
            subblocks = {}
            for child in current_yaml["subblocks"]:
                self._addToMasterDict(child)
                subblocks[child["name"]] = child
        self.all_paths[current_yaml["name"]] = current_yaml

    def _createMasterDict(self):
        self.all_paths = {}
        for yaml_it in self.yaml_data:
            self._addToMasterDict(yaml_it)

    def _getRawDump(self, app_path):
        """
        Generate the raw data from the executable.
        Return:
            the data
        """
        data = ExeLauncher.runExe(app_path, "--yaml")
        data = data.split('**START YAML DATA**\n')[1]
        data = data.split('**END YAML DATA**')[0]
        return data

    def findPath(self, path):
        """
        Find the YAML entry of the path
        Input:
            path: Path of entry
        Return:
            YAML entry if found, else None
        """
        return self.all_paths.get(path, None)

    def prettyPrintEntry(self, path):
        """
        Returns a YAML entry of a path
        Input:
            path: Path of YAML entry
        """
        entry = self.findPath(path)
        if entry:
            return json.dumps(entry, indent=2)

    def _dumpNames(self, output, y, level, sep='  '):
        """
        Just adds the name of the parameters and subblocks
        Input:
            output[StringIO]: where to write to
            y[dict]: current yaml entry
            level[int]: how deep we are
            sep[str]: each level will be prefixed with this str
        """
        output.write("%s%s:\n" % (level*sep, y["name"]))
        if y["parameters"]:
            output.write("%sParameters:\n" % (sep*(level+1)))
            for param in y["parameters"]:
                output.write("%s%s\n" % ( sep*(level+2), param["name"]))

        if y["subblocks"]:
            output.write("%sSubblocks:\n" % (sep*(level+1)))
            for s in y["subblocks"]:
                self._dumpNames(output, s, level+2, sep)

    def dumpNames(self):
        """
        Just dump the list of names of paths, parameters, and subblocks
        """
        output = cStringIO.StringIO()
        for yaml_it in self.yaml_data:
            self._dumpNames(output, yaml_it, 0, sep='  ')
        return output.getvalue()

    def toPickle(self):
        """
        Return a dict that can be pickled
        """
        return {"app_path": self.app_path,
                "yaml_data": self.yaml_data,
                "all_paths": self.all_paths,
                }

    def fromPickle(self, data):
        """
        Read in from a dict that was once pickled.
        Input:
            data[dict]: dict that was generated from toPickle()
        """
        self.app_path = data["app_path"]
        self.yaml_data = data["yaml_data"]
        self.all_paths = data["all_paths"]

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 2:
        print("Usage: %s <exe path>" % sys.argv[0])
        sys.exit(1)
    y = YamlData(sys.argv[1])
    #print(y.dumpNames())
    # print(json.dumps(y.all_entries, indent=2))
    print(y.all_entries.keys())
    #y._createMasterDict()
    #y.findPath('/Adaptivity/Markers')
    #print(json.dumps(y.yaml_data, indent=2))
